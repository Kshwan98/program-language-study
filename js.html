<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //숫자
            //1.수의 표현
            //프로그래밍 입문자에게 가장 익숙한 데이터 형(data type)은 숫자와 문자일 것이다.
            
            //2.수의 연산
            alert (1+1);
            alert ("1"+"1");
            Math.pow(3,2);       // 9,   3의 2승 
            Math.round(10.6);    // 11,  10.6을 반올림
            Math.ceil(10.2);     // 11,  10.2를 올림
            Math.floor(10.6);    // 10,  10.6을 내림
            Math.sqrt(9);        // 3,   3의 제곱근
            Math.random();       // 0부터 1.0 사이의 랜덤한 숫자
            Math.round(100 * Math.random());  //100 이하 랜덤으로 소수점 숫자 고른 후 반올림.

        
        //문자
            //1.문자의 푠현
            // 문자: 문자는 "(큰 따옴표) 혹은 '(작은 따옴표) 중의 하나로 감싸야 한다. 큰 따옴표로 시작하면 큰 따옴표로 끝나야하고, 작은 따옴표로 시작하면 작은 따옴표로 끝나야 한다. String(문자열)이라고 한다.

            EX) alert("coding everybody");
                alert('coding everybody');

            //숫자를 따옴표로 감싸면 문자가 된다. 아래는 문자다. typeof는 값의 데이터 형을 알려주는 기능이다.
            alert(typeof "1")
            결과 : string

            //아래와 같이 따옴표 없는 숫자는 number가 출력된다.
            alert(typeof 1)
            결과 : number

            //만약 문자열 안에 작은 따옴표나 큰따옴표를 넣고 싶다면?
            alert('egoing's javascript')
            //위의 내용은 문법(Syntax) 에러(Error)가 발생했다는 뜻이다. 작은따옴표는 문자열의 구간을 컴퓨터에게 알려주는 기호인데, 기호가 문자 자체로 사용됐기 때문에 컴퓨터 입장에서는 어디서부터 어디까지가 문자열인지 파악 할 수 없게 된 것이다.

            alert('egoing\'s javascript')
            // \를 ' 앞에 위치시키면 ' 를 문자열의 시작과 끝을 구분하는 구분자가 아니라 단순히 문자로 해석하도록 강제 할 수 있다. 이러한 기법을 이스케이프(escape)라고 한다.

        
            //2. 문자의 연산
            //여러줄을 표시하기 위해서는 아래와 같이 한다. \n는 줄바꿈을 의미하는 특수한 문자다.
            alert("안녕하세요.\n생활코딩의 세계에 오신 것을 환영합니다"); 

            //문자연산
            //문자와 문자를 더할 때는 아래와 같이 한다.
            alert("coding"+" everybody");
            결과 : coding everybody

            //문자의 길이를 구할 때는 문자 뒤에 .length를 붙인다.
            alert("coding everybody".length)
            결과 : 16


        //변수
            //1.변수의 사용법
            //변수 : 변수(Variable)는 (문자나 숫자 같은) 값을 담는 컨테이너로 값을 유지할 필요가 있을 때 사용한다. 여기에 담겨진 값은 다른 값으로 바꿀 수 있다. 변수는 마치 (사람이 쓰는 언어인) 자연어에서 대명사와 비슷한 역할을 한다.

            //(1)변수의 선언
            //JavaScript에서 변수는 var로 시작한다. var은 변수를 선언하겠다는 것을 의미한다. var을 생략 할수도 있지만 이것은 유효범위라는 것에 영향을 미친다. 그렇기 때문에 var의 의미를 명확하게 이해하기 전까지는 var를 사용하는 것이 권장된다. 유효범위에 대해서는 뒤에서 살펴볼 것이다. 변수의 이름은 $, _, 혹은 특수 문자를 제외한 모든 문자로 시작할 수 있다. 다음 예제는 변수에 값을 대입한 예제다.
            EX) var a = 1;
                alert(a+1);  //2
                var a = 2;
                alert(a+1);  //3
            //위의 실습 결과는 각각 2와 3이 출력될 것이다. 변수 a에 담겨 있는 값이 1일 때는 a+1의 결과가 2가 된다. 두번째 결과가 3이 된 것은 a의 값이 2로 바뀌었고, 2+1의 결과인 3이 출력된 것이다.
            
            //다음 예제는 변수의 값이 꼭  숫자만 올 수 있는 것은 아니라는 것을 보여주기 위해서 만든 예제다.
            var first = "coding";
            alert(first+" everybody");
            //변수 a에 coding ,변수 b에 everybody를 활당하는 방법은 아래와 같다
            var a = 'coding', b = 'everybody';
            alert(a);
            alert(b);

            //2. 변수의 효용
            //변수는 코드의 재활용성을 높여준다. 예를들어서 100에 10을 더하고, 10을 나눈 후에 다시 10을 빼고 거기에 10을 곱해야 한다고 치자. 그리고 각 단계마다 그 결과를 출력해야 한다면 코드는 아래와 같을 것이다.
            alert(100+10);
            alert((100+10)/10);
            alert(((100+10)/10)-10);
            alert((((100+10)/10)-10)*10);
            
            //그런데 계산해야 할 값을 100이 아니라 1000으로 바꿔야 한다면 위의 코드를 모두 수정해야 할 것이다. 변수를 적용해보자.
            a = 100;
            a = a + 10;
            alert(a);
            a = a / 10;
            alert(a);
            a = a - 10;
            alert(a);
            a = a * 10;      
            alert(a);
            //위의 코드에서 첫번째 줄의 100을 다른 숫자로 바꾸면 나머지 로직에 대입되는 변수의 값이 모두 바뀐다. 수정해야 할 코드가 적다는 것은 그만큼 해야 할 일이 줄어든다는 의미고, 그 과정에서 버그가 발생할 가능성을 낮출 수 있다. 변수의 효용은 뒤에서 배우게 될 반복문, 조건문, 함수와 결합되면 더욱 더 중요해진다.


        //비교 
            //1.연사잔란 : 연산자란 값에 대해서 어떤 작업을 컴퓨터에게 지시하기 위한 기호인데 우리는 이미 연산자를 사용했다. 아래 예제 중에서 '='는 우항의 값인 1을 좌항의 변수 a에 대입하는 '대입 연산자'다. 
            a=1

            //2.== ===
            //프로그래밍에서 비교란 주어진 값들이 같은지, 다른지, 큰지, 작은지를 구분하는 것을 의미한다. 이 때 비교 연산자를 사용하는데 비교 연산자의 결과는 true나 false 중의 하나다. true는 비교 결과가 참이라는 의미이고, false는 거짓이라는 뜻이다. true와 false는 블린(boolean)이라고 불리는 데이터 형식이다.
            //아래는 주요한 비교 연산자들의 종류와 그에 따른 예제들이다.

            //(1)== : 동등 연산자로 좌항과 우항을 비교해서 서로 값이 같다면 true 다르다면 false가 된다. '='가 두개인 것을 주의하자. '='가 하나인 것은 대입 연산자로 우항의 값을 좌항의 변수에 대입할 때 사용하는 것으로 의미가 완전히 다르다.
            alert(1==2)             //false
            alert(1==1)             //true
            alert("one"=="two")     //false 
            alert("one"=="one")     //true

            //(2)=== : 일치 연산자로 === 좌항과 우항이 '정확'하게 같을 때 true 다르면 false가 된다. 여기서 정확하다는 말의 의미에 집중하자. 아래 예를보면
            alert(1=='1');              //true
            alert(1==='1');             //false
            //위의 결과는 이상하다. '==='는 숫자 1과 문자 1을 다르게 인식한다. 반면에 '=='는 양쪽의 값을 같다고 판단한다. 바로 이것이 '정확'의 의미다. 즉 ===는 서로 같은 수를 표현하고 있더라도 데이터 형이 같은 경우에만 같다고 판단하기 때문이다. 결론부터 말하면 == 연산자 대신 === 연산자를 쓰는 것을 강력하게 권한다. 아래는 일치 연산자와 대입연산자의 차이를 보여준다.
            alert(null == undefined);       //true
            alert(null === undefined);      //false
            alert(true == 1);               //true true=1 로 간주
            alert(true === 1);              //false
            alert(true == '1');             //true
            alert(true === '1');            //false
            
            alert(0 === -0);                //true
            alert(NaN === NaN);             //false NaN = 0/0

            //3.부정과 부등호 
            //(1) != : '!'는 부정을 의미한다. '같다(==)'의 부정은 '같지 않다'이다. 이것을 기호로는 '!='로 표시한다. 아래의 결과는 !=의 결과인데 ==와 정반대의 결과를 보여준다.]
            alert(1!=2);            //true
            alert(1!=1);            //false
            alert("one"!="two");    //true
            alert("one"!="one");    //false

            //(2) '!=='는 '==='의 부정이다.
            
            //(3) > : 좌항이 우항보다 크다면 참, 그렇지 않다면 거짓임을 알려주는 연산자다. '<'는 >의 반대의 의미
            alert(10>20);   //false
            alert(10>1);    //true
            alert(10>10);   //false
            
            //(4) >= : 좌항이 우항보다 크거나 같다. '<='는 반대의 의미
            alert(10>=20);      //false
            alert(10>=1);       //true
            alert(10>=10);      //true


        //조건문 : 주어진 조건에 따라서 에플리케이션을 다르게 동작하도록 하는 것이다.
            
            //1.조건문문법 
            //(1)if
            //조건문은 if로 시작한다. if 뒤의 괄호에 조건이 오고, 조건이 될 수 있는 값는 Boolean이다. Boolean의 값이 true라면 조건이 담겨진 괄호 다음의 중괄호 구문이 실행된다.
            //아래 예제의 실행결과는 'result : true'다. if 뒤에 true가 왔기 때문이다.
            if(true){
            alert('result : true');}
            
            //다음 예제는 아무것도 출력하지 않을 것이다. if 뒤에 false가 왔기 때문이다.
            if(false){
            alert('result : true');}
            
            
            //(2)else
            //if만으로는 좀 더 복잡한 상황을 처리하는데 부족하다. 아래 예제를 보자. 결과는 1이다.
            if(true){
                alert(1);
            } else {
                alert(2);
            }
            //다음 예제의 결과는 2다.
            if(false){
                alert(1);
            } else {
                alert(2);
            }
            //if문의 조건이 true라면 if의 중괄호 구간이 실행되고, false라면 else 이후의 중괄호 구간이 실행된다. 즉 else는 주어진 조건이 거짓일 때 실행할 구간을 정의하는 것이다.

            
            //(3) else if
            //else if를 이용하면 조건문을 좀 더 풍부하게 할 수 있다. 아래 예제를 보자. 결과는 2다.
            if(false){
                alert(1);
            } else if(true){
                alert(2);
            } else if(true){
                alert(3);
            } else {
                alert(4);
            }
            //다음 예제의 결과는 3이다.
            if(false){
                alert(1);
            } else if(false){
                alert(2);
            } else if(true){
                alert(3);
            } else {
                alert(4);
            }
            //다음 예제의 결과는 4다.
            if(false){
                alert(1);
            } else if(false){
                alert(2);
            } else if(false){
                alert(3);
            } else {
                alert(4);
            }
            //else if는 좀 더 다양한 케이스의 조건을 검사할 수 있는 기회를 제공한다. else if의 특징은 if나 else와는 다르게 여러개가 올 수 있다는 점이다. else if의 모든 조건이 false라면 else가 실행된다. else는 생략 가능하다.

            
            //(4) 조건문의 응용
            //변수와 비교연산자
            //ID의 값으로 SW을 입력해보고, 다른 값도 입력해보자. 아래의 예제는 브라우저에서 실행해야 한다. 다른 환경에서는 원하는데로 동작하지 않을 것이다.
            id = prompt('아이디를 입력해주세요.')
            if(id ==='SW'){
                alert('아이디가 일치 합니다.')
            } else {
                alert('아이디가 일치하지 않습니다.')
            }
            //위의 내용에서 prompt() 구문은 사용자가 입력한 값을 가져와서 id 변수의 값으로 대입한다. 이러한 것을 API 또는 함수라고 부른다, 사용자가 입력한 값이 SW이라면 '아이디가 일치 합니다'를 출력하고 그렇지 않다면 '아이디가 일치하지 않습니다'를 출력한다.

            //조건문의 중첩
            //위의 예제에서 아이디와 비밀번호를 모두 검증해야 한다면 어떻게 하면 될까? 다음 예제를 보자.
            id = prompt('아이디를 입력해주세요.');
            if(id ==='SW'){
                password = prompt('비밀번호를 입력해주세요.');
                if(password==='111111'){
                    alert('인증 했습니다.');
                } else {
                    alert('인증에 실패 했습니다.');
                }
            } else {
                alert('인증에 실패 했습니다.');
            }
            //if문 안에 다시 if문이 등장했다. 즉 사용자가 입력한 값과 아이디의 값이 일치하는지를 확인한 후에 일치한다면 비밀번호가 일치하는지 확인한 것이다. 이렇게 조건문은 조건문 안에 중첩해서 사용될 수 있다.

            
            //(5) 논리 연산자 : 논리 연산자는 조건문을 좀 더 간결하고 다양한 방법으로 구사할 수 있도록 도와준다.
            //&& : 좌항과 우항이 모두 참(true)일 때 참이된다. 다음 예제를 보자. 결과는 1이다. &&의 좌우항이 모두 true인 것은 첫번째 조건문 밖에 없기 때문이다. 이러한 논리 연산자를 and 연산자라고 한다.
            if(true && true){
                alert(1);           //결과 값 : 1
            }
            if(true && false){
                alert(2);           //결과 값 : 작동 안됨
            }
            if(false && true){
                alert(3);           //결과 값 : 작동 안됨               
            }
            if(false && false){
                alert(4);           //결과 값 : 작동 안됨
            }
            
            //논리 연산자를 이용한 사례를 살펴보자. 다음 예제는 논리 연산자를 이용해서 이전 예제를 개선한 것이다.
            id = prompt('아이디를 입력해주세요.');
            password = prompt('비밀번호를 입력해주세요.');
            if(id ==='SW' && password ==='111111'){
                alert('인증 했습니다.');
            } else {
                alert('인증에 실패 했습니다.');
            }
            //중첩된 if문을 하나로 줄였다. 덕분에 코드의 복잡성도 낮아졌다. &&는 아래와 같은 의미를 만든다."id의 값이 SW이고 password의 값이 111111이면 참이다"즉 && 연산자의 좌항과 우항이 모두 참일 때 전체가 참이 되는 것이다.

            // || : 좌우항 중에 하나라도 true라면 true가 되는 논리 연산자다. or 연산자라고 부른다. 다음 예를 보자. 결과는 1,2,3이 출력된다. 마지막 조건문의 '||'는 좌항과 우항이 모두 false이기 때문에 false가 된다.
            if(true || true){
                alert(1);          //결과 값 : 1
            }
            if(true || false){
                alert(2);          //결과 값 : 2
            }
            if(false || true){
                alert(3);          //결과 값 : 3
            }
            if(false || false){
                alert(4);          //결과 값 : 작동하지 않음.
            }
            
            //다음 예제는 id 값으로 SW, IS, AN 중의 하나를 입력하면 '인증 했습니다'가 출력되고, 그 외의 값을 입력하면 '인증에 실패 했습니다.'를 출력하는 예제다.
            id = prompt('아이디를 입력해주세요.');
            if(id==='SW' || id==='IS' || id==='AN'){
                alert('인증 했습니다.');
            } else {
                alert('인증에 실패 했습니다.');
            }
            //위의 예제에서는 논리 연산자를 3개 사용했다. 2개만 사용하는 것이 아니라는 것을 보여주기 위한 예제다.

            //다음 예제는 id 값으로 SW, IS, AN 중의 하나를 사용하고 비밀번호는 111111을 입력하면 right 외의 경우에는 wrong를 출력하는 예다.
            id = prompt('아이디를 입력해주세요.');
            password = prompt('비밀번호를 입력해주세요.');
            if((id==='SW' || id==='IS' || id==='AN') && password==='111111'){
                alert('인증 했습니다.');
            } else {
                alert('인증에 실패 했습니다.');
            }
            //위의 예제에서는 or와 and를 혼합해서 사용하는 방법을 보여준다. id 값을 테스트 하는 구간을 괄호()로 묶었다. 사용자가 id의 값으로 SW, 비밀번호를 111111을 입력했다면 연산의 순서는 아래와 같이 된다.

            //1.(id=="egoing" or id=="k8805" or id=="sorialgi") : true가 된다.
            //2.password=='111111' : true가 된다.
            //3.true(1항) and true(2항) : true가 된다.
            
            //id 비교를 할 때 괄호를 사용한 것은 사칙 연산을 할 때 괄호부터 계산하는 것과 같은 원리다.

            // ! : 부정의 의미로, Boolean의 값을 역전시킨다. true를 false로 false를 true로 만든다. not 연산자라고 부른다. 아래의 결과는 4다.
            if(!true && !true){
                alert(1);
            }
            if(!false && !true){
                alert(2);
            }
            if(!true && !false){
                alert(3);
            }
            if(!false && !false){
                alert(4);
            }


            //(6) boolean의 대체재 
            //조건문에 사용될 수 있는 데이터 형이 꼭 불린만 되는 것은 아니다. 관습적인 이유로 0는 false 0이 아닌 값은 true로 간주된다. 아래의 예제는 2를 출력한다.
            if(0){
                alert(1)    //결과값 : 작동안함
            }
            if(1){
                alert(2)    // 결과값 : 2
            }

            //기타 false로 간주되는 데이터 형
            //다음은 false와 0 외에 false로 간주되는 데이터형의 리스트다. if문의 조건으로 !(부정) 연산자를 사용했기 때문에 각 조건문의 첫번째 블록이 실행되는 것은 주어진 값이 false이기 때문이다.
            if(!''){
                alert('빈 문자열')
            }
            if(!undefined){
                alert('undefined');
            }
            var a;
            if(!a){
                alert('값이 할당되지 않은 변수'); 
            }
            if(!null){
                alert('null');
            }
            if(!NaN){
                alert('NaN');
            }

        
        //반복문 : 컴퓨터에게 반복적인 작업을 지시하는 방법이다.
           
            //(1) 반복문의 문법 
                //while (조건(boolean)) {
                    //반복해서 실행할 코드}
                ex) while (true) {
                    document.write ("holle word <br />" );
                }
                while (false) {
                    document.write ("holle word <br />" );
                }
                //while문은 while문 뒤에 따라오는 괄호 안의 조건이 참(true)면 중괄호 안의 코드 구간을 반복적으로 실행한다. 조건이 false면 반복문이 실행되지 않는다. 여기서 true와 false는 종료조건이 되는데, 이 값을 변경하는 것을 통해서 반복문을 종료시킬 수 있다. 반복문에서 종료조건을 잘못 지정하면 무한반복이 되거나, 반복문이 실행되지 않는다.
                
            //(2) 반복문 조건 
               ex)  var i = 0;
                // 종료조건으로 i의 값이 10보다 작다면 true, 같거나 크다면 false가 된다.
                while(i < 10){
                // 반복이 실행될 때마다 coding everybody <br />이 출력된다. <br /> 줄바꿈을 의미하는 HTML 태그
                document.write('coding everybody <br />');
                // i의 값이 1씩 증가한다. i+=1 처럼 쓸수도 있다. 
                i= i+1
                }
            
            //(3) for문
                for(초기화; 반복조건; 반복이 될 때마다 실행되는 코드){
                    반복해서 실행될 코드
                }
                
                ex) for(var i = 0; i < 10; i++){
                    document.write('coding everybody'+i+'<br />');
                }    
                //for문은 제일 먼저 '초기화'를 한다. 위의 예제에서 초기화는 var i = 0;이다. 즉 변수 i의 값을 0으로 설정한 것이다. 그 다음에는 '반복조건'인 i < 10이 실행된다. 현재 i의 값은 0이다. 그렇기 때문에 이 조건은 참이다. 반복조건이 참이면 중괄호 안의 내용이 실행된다. i의 값이 0이기 때문에 'coding everybody0<br />'이라는 텍스트가 출력된다. '반복해서 실행될 코드'의 실행이 끝나면 '반복이 될 때마다 실행되는 코드'가 실행된다. i++는 현재 i의 값에 1을 더하라는 의미다. 현재 i의 값은 0이다. 따라서 i++의 결과로 i는 1이 되었다. 그리고 '반복조건'이 실행된다. 현재 i의 값은 1이기 때문에 i < 10은 참이다. 다시 '반복해서 실행될 코드'가 실행된다. 그렇게 반복해서 작업이 실행된다. 이 과정에서 i의 값은 반복 할 때마다 1씩 증가한다. 결국 i의 값이 10이 되는 순간 i < 10을 충족시키지 못하게 되고 반복문은 종료된다.

                //+i+은 문자열 뒤에 숫자를 붙여주는 것이다.
                
                // 문자열뒤에 2의 배수를 붙이고 싶으면 "+(i*2)+"을 붙여주면 된다.
                
                //i++와 ++i은 i= i+1 과 같다 그러나 여기서 두개의 차이점은
                //i++은 실행될때 i+0으로 시작하고 ++i은 i+1로 시작하는 차이점이 있다. 그러나 위예에서는 의미차이는 없으므로 똑같다. 
            
            //(4) break : 반복작업을 중간에 중단시키는 기능이다 아래의 예제는 위에서 살펴본 예제를 일부 변형한 것이다.

                for(var i = 0; i < 10; i++){
                    if(i === 5) {
                        break;
                    }
                    document.write('coding everybody'+i+'<br />');
                }

               //위 코드의 결과는 아래와 같다.
                coding everybody 0
                coding everybody 1
                coding everybody 2
                coding everybody 3
                coding everybody 4
               //종료조건에 따르면 10행이 출력돼야 하는데 5행만 출력되었다. 2행의 if(i === 5) 에 의해서 i의 값이 5일 때 break 문이 실행되면서 반복문이 완전히 종료된 것이다. 반복문 안에서 break가 실행되면 반복문을 즉시 종료시키는 것이다.
               
            //(5) continue
                //실행 즉시 중단 하면서 반복은 지속돼게 하는 기능이다 예제를 보자. 이전 예제의 break를 continue로 변경했을 뿐이지만 결과는 전혀 다르다.

                for(var i = 0; i < 10; i++){
                    if(i === 5) {
                        continue;
                    }
                    document.write('coding everybody'+i+'<br />');
                }

                //결과는 아래와 같다. 숫자 5가 보이지 않는다. 왜 그럴까? i의 값이 5가 되었을 때 실행이 중단 됐기 때문에 continue 이후의 구문이 실행되지 않은 것이다. 하지만 반복문은 중단되지 않았기 때문에 나머지 결과가 출력된 것이다.

                coding everybody 0
                coding everybody 1
                coding everybody 2
                coding everybody 3
                coding everybody 4
                coding everybody 6
                coding everybody 7
                coding everybody 8
                coding everybody 9
        
            //(6) 반복문의 중첩 : 반복문 안에는 다시 반복문이 나타날 수 있다. 다음 예제를 보자. 다음 예제는 00, 01, 02....99 까지를 화면에 출력한다.

                ex) // 0부터 9까지 변수 i에 순차적으로 값을 할당        
                for(var i = 0; i < 10; i++){
                    // 0부터 9까지의 변수를 j의 값에 순차적으로 할당
                    for(var j = 0; j < 10; j++){    
                        // i와 j의 값을 더한 후에 출력
                        // String은 숫자인 i와 j의 데이터 타입을 문자로 형태를 변환하는 명령이다. 
                        // String()을 제거하고 실행해보면 의미가 좀 더 분명하게 드러날 것이다.
                        document.write(String(i)+String(j)+'<br />');
                    }
                }
        
                
        //함수 
            //함수란 : 함수(function)란 하나의 로직을 재실행 할 수 있도록 하는 것으로 코드의 재사용성을 높여준다.
            
                //함수의 형식 
                function 함수명( [인자...[,인자]] ){
                    코드
                    return 반환값
                }

                //함수는 function 뒤에 함수의 이름이 오고, 소괄호가 따라온다. 소괄호에 인자라는 값이 차례로 들어오는데 이 값은 함수를 호출할 때 함수의 로직으로 전달될 변수다. 인자는 생략 할 수 있다. 함수를 호출 했을 때 실행하게 될 부분이 중괄호 안쪽에 온다.

                //다음 예제를 보자. 이 함수의 이름은 numbering이고, 내용은 0부터 9까지를 화면에 출력한다.

                function numbering(){
                    i = 0;
                    while(i < 10){
                        document.write(i);
                        i += 1;
                    }   
                }
                numbering();

                //결과는 아래와 같다
                0123456789

            // 입력과 출력
                //함수의 핵심은 입력과 출력이다. 입력된 값을 연산해서 출력하는 것이 함수의 기본적인 역할이다. 다음은 함수에서 입력과 출력의 역할을 하는 구문들에 대한 설명이다.

                //(1) return (출력)
                //함수 내에서 사용한 return은 return 뒤에 따라오는 값을 함수의 결과로 반환한다. 동시에 함수를 종료시킨다. 아래 내용을 보자. 결과는 SW과 AN다.

                ex) function get_member1(){
                        return 'SW';
                    }
                    
                    function get_member2(){
                        return 'AN';
                    }
                    
                    alert(get_member1());
                    alert(get_member2());

                //get_member1와 get_member2를 출력(alert)한 결과가 각각 SW과 AN인 이유는 함수 내에서 문자열 SW과 AN을 return을 하기 때문이다.
                //return은 결과를 반환하는 것 외에 함수를 중지시키는 역할도 한다. 다음 코드를 보자. 결과는 SWs이다.

                function get_member(){
                    return 'SW';
                    return 'AN';
                    return 'IS';
                }
                alert(get_member());

                //AN와 IS는 출력하지 않았다. 왜 그럴까? 그것은 return 'SW'을 실행한 후에 함수가 종료되었기 때문이다. return 'AN' 이하는 어떠한 경우도 실행되지 않는다.

            //입력 인자란?
            
                //인자(argument)는 함수로 유입되는 입력 값을 의미하는데, 어떤 값을 인자로 전달하느냐에 따라서 함수가 반환하는 값이나 메소드의 동작방법을 다르게 할 수 있다. 다음 예를보자. 결과는 1,2이다.

                function get_argument(arg){
                        return arg;
                    }
                    
                    alert(get_argument(1));
                    alert(get_argument(2));

                //5행의 get_argument(1)은 1행에서 3행 사이에 정의된 함수를 실행하는 구문이다. 5행의 1은 get_argument로 1이라는 값을 전달하겠다는 의미다. 이 때 1행에 정의된 (arg) 구문에 의해서 변수 arg의 값으로 숫자 1이 함수 안으로 전달된다. 이 변수 arg는 함수 get_argument 안에서만 유효하다. 

                //복수인자 
                // 여러개의 입력 값을 받고 싶다면 어떻게 해야할까? 다음 예제를 보자. 결과는 30과 50이다.

                function get_arguments(arg1, arg2){
                        return arg1 + arg2
                    }
                    
                    alert(get_arguments(10, 20));
                    alert(get_arguments(20, 30));

                //아래 예제는 표현은 다르지만 뜻은 같다고 할 수 있다. 
                    var numbering = function (){
                    i = 0;
                    while(i < 10){
                        document.write(i);
                        i += 1;
                    }   
                }
                numbering();

                    
                function numbering(){
                    i = 0;
                    while(i < 10){
                        document.write(i);
                        i += 1;
                    }   
                }

                //아래 예제는 익명함수라고 해서 함수가 정해지진 않았다는 것이다. 
                (function (){
                    i = 0;
                    while(i < 10){
                        document.write(i);
                        i += 1;
                    }
                }) 
                ();


        //배열  
                //배열(array)이란 연관된 데이터를 모아서 통으로 관리하기 위해서 사용하는 데이터 타입이다. 변수가 하나의 데이터를 저장하기 위한 것이라면 배열은 여러 개의 데이터를 하나의 변수에 저장하기 위한 것이라고 할 수 있다. 아래의 예제를 보자. 변수 name에는 문자 SW이 할당되었다. 이제부터 name을 호출하면 문자 SW을 사용할 수 있다.

                var name = 'SW'
                alert(name);

                //그렇다면 여러 개의 데이터를 하나의 변수에 담아서 관리할 수 있는 방법은 없을까? 있다. 배열을 쓰면 된다. 변수 member에 회원정보를 담아보자. 대괄호([])는 배열을 만드는 기호다. 대괄호 안에 데이터를 콤마(,)로 구분해서 나열하면 배열이 된다.

                var member = ['SW', 'AN', 'IS']
                alert(member);  
                
                //하나의 변수에 3개의 데이터를 담았다. 각각의 데이터를 원소(Element)이라고 부른다. 자 그럼 이 데이터를 꺼내오려면 어떻게 해야 할까? 아래의 예제를 보자.

                var member = ['SW', 'AN', 'IS']
                alert(member[0]);
                alert(member[1]);
                alert(member[2]);

                //결과는 아래의 문자열을 차례로 경고창으로 출력 할 것이다.

                SM
                AN
                IS
                //즉 배열에 담겨있는 값을 가져올 때는 대괄호 안에 숫자를 넣는다. 이 숫자를 색인(index)라고 부르고 0부터 시작한다. 즉 첫번째 원소(egoing)를 가져오려면 대괄호 안에 0을 넣어주어야 한다는 것이다. 두번째는 1, 세번째는 2를 입력한다. 이 값을 이용해서 배열에 저정된 값을 가져올 수 있다.

                //이번엔 배열를 이용한 아래의 코드를 보자. 맴버를 담고 있는 배열를 반환하고 있다. 간단하지 않은가?

                function get_members(){
                    return ['sw', 'an', 'is'];
                }
                var members = get_members();
                document.write(members[0]);
                document.write(members[1]);
                document.write(members[2]);

            //(1) 배열과 반복문의 조우
               // 배열의 진가는 반복문과 결합했을 때 나타난다. 반복문으로 리스트에 담긴 정보를 하나씩 꺼내서 처리 할 수 있기 때문이다. 다음 예제를 보자

               function get_members(){
                    return ['sw', 'an', 'is'];
                }
                members = get_members();
                // members.length는 배열에 담긴 값의 숫자를 알려준다. 
                for(i = 0; i < members.length; i++){
                    // members[i].toUpperCase()는 members[i]에 담긴 문자를 대문자로 변환해준다.
                    document.write(members[i].toUpperCase());   
                    document.write('<br />');
                }

                //결과는 아래와 같다.

                SW
                AN
                IS

                //위의 예제에서 주목해야 할 것은 반복문과 배열을 결합한 부분이다. 반복문을 이용해서 배열 members의 내용을 하나씩 꺼낸 후에 이름의 첫글자를 대문자로 변경한 후에 출력하고 있다. 정리하면, 배열이란 연관된 정보를 하나의 그룹으로 관리하기 위해서 사용한다. 그리고 그 정보를 처리 할 때는 반복문을 이용한다.

                //아래와 같은 방법으로 배열의 크기를 알아낼 수 있다. 결과는 5이다.

                var arr = [1, 2, 3, 4, 5];
                alert(arr.length);

            //(2) 원소의 추가
                //다음은 배열의 끝에 원소를 추가하는 방법이다. push는 인자로 전달된 값을 배열(li)에 추가하는 명령이다. 배열 li의 값은 a, b, c, d, e, f가 됐다.

                var li = ['a', 'b', 'c', 'd', 'e'];
                li.push('f');
                alert(li);

                //다음은 복수의 원소를 배열에 추가하는 방법이다. concat은 인자로 전달된 값을 추가하는 명령이다.

                var li = ['a', 'b', 'c', 'd', 'e'];
                li = li.concat(['f', 'g']);
                alert(li);

                //다음은 배열의 시작점에 원소를 추가하는 방법이다. 배열 li는 z, a, b, c, d, e가 됐다. unshift는 인자로 전달한 값을 배열의 첫번째 원소로 추가하고 배열의 기존 값들의 색인을 1씩 증가시킨다.

                var li = ['a', 'b', 'c', 'd', 'e'];
                li.unshift('z');
                alert(li);

                //만약 두번째 인덱스 뒤에 대문자 B를 넣고 싶다면 아래와 같이한다. splice는 첫번째 인자에 해당하는 원소부터 두번째 인자에 해당하는 원소의 숫자만큼의 값을 배열로부터 제거한 후에 리턴한다. 그리고 세번째 인자부터 전달된 인자들을 첫번째 인자의 원소 뒤에 추가한다.

                var li = ['a', 'b', 'c', 'd', 'e'];
                li.splice(2, 0, 'B');
                alert(li);
                    
                var li = ['a', 'b', 'c', 'd', 'e'];
                li.splice(2, 0, 'B');
                alert(li);
                //그리고 splice 두번째 자리에 숫자1을 넣으면 해당자리 원소를 제거하고 그자리에 추가하는 원소를 넣을 수 있다. 

            //(3)원소의 제거와 정렬
                //제거
                //다음은 배열의 첫번째 원소를 제거하는 방법이다. shift를 사용하면 된다. 아래 결과는 b, c, d, e 다.

                var li = ['a', 'b', 'c', 'd', 'e'];
                li.shift();
                alert(li);

                //다음은 배열 끝점의 원소를 배열 li에서 제거한다. 이때는 pop를 사용한다. 결과는 a, b, c, d 다.

                var li = ['a', 'b', 'c', 'd', 'e'];
                li.pop();
                alert(li); 

                //정렬
                var li = ['c', 'e', 'a', 'b', 'd'];
                li.sort();
                alert(li);

                //역순으로 정렬하고 싶을 때는 아래와 같이 한다.

                var li = ['c', 'e', 'a', 'b', 'd'];
                li.reverse();
                alert(li);

        
        //객체
            //지금까지 살펴본 배열은 아이템에 대한 식별자로 숫자를 사용했다. 데이터가 추가되면 배열 전체에서 중복되지 않는 인덱스가 자동으로 만들어져서 추가된 데이터에 대한 식별자가 된다. 이 인덱스를 이용해서 데이터를 가져오게 되는 것이다. 만약 인덱스로 문자를 사용하고 싶다면 객체(dictionary)를 사용해야 한다. 다른 언어에서는 연관배열(associative array) 또는 맵( map), 딕셔너리(Dictionary)라는 데이터 타입이 객체에 해당한다.

            //다음은 객체를 만드는 법이다.

            var grades = {'SW': 10, 'AN': 6, 'IS': 80};

            //위의 예제에서 SW은 key(index)가 되고, 10은 value(index의 값)가 된다. 아래는 객체를 만드는 다른 방법이다.

            var grades = {};
            grades['SW'] = 10;
            grades['AN'] = 6;
            grades['IS'] = 80;

            //아래와 같은 방법으로 객체를 만들수도 있다.

            var grades = new Object();
            grades['SW'] = 10;
            grades['AN'] = 6;
            grades['IS'] = 80;

            //객체를 만들었으니 이제는 객체에서 필요한 값을 가져와보자. 다음은 IS라는 이름(key)으로 저장된 값을 가져오는 법이다. 결과는 80이다.

            var grades = {'SW': 10, 'AN': 6, 'IS': 80};
            alert(grades['IS']);

            //다음 방법으로도 객체의 속성에 접근 할 수 있다.

            alert(grades.IS);
            alert(grades['I'+'s']);
            
            // 단 아래와 같은 방법으로는 객체의 속성에 접근 할 수 없다.
            alert(grades.'I'+'S')
            
            //(1)  for in loop  
            //다음은 객체에 저장된 데이터를 기준으로 반복작업을 하는 방법이다.

            var grades = {'SW': 10, 'AN': 6, 'IS': 80};
            for(key in grades) {
                document.write("key : "+key+" value : "+grades[key]+"<br />");
            }

            //결과는 아래와 같다.

            key :   SW value : 10
            key :   AN value : 6
            key :   IS value : 80

            //for 문은 in 뒤에 따라오는 배열의 key 값을 in 앞의 변수 name(위 예제에서 Key이다) 에 담아서 반복문을 실행한다. 반복문이 실행될 때 변수 key의 값으로 SW, AN, IS가 순차적으로 할당되기 때문에 grades[key]를 통해서 객체의 값을 알아낼 수 있다.

            //(3)객체 지향 프로그래밍
           //객체에는 객체를 담을수도 있고, 함수도 담을 수 있다. 

           var grades = {
                'list': {'SW': 10, 'AN': 6, 'IS': 80},
                'show' : function(){
                    for(var name in this.list){
                        document.write(name+':'+this.list[name]+"<br />");
                    }
                }
            };
            grades.show();

            //위예제에서 this는 list, show가 속해있는 소속 grades을 가리킨다. list은 Key이고 : 이후에 오는 것은 key의 값이다. 즉 객체안에 객체가 올 수 있다. 그리고 객체안에도 함수가 올 수 있다 그 이유는 함수도 값을 치기 때문이다.  
            
            //이것은 자바스크립트를 이용한 객체 지향 프로그래밍 기법의 핵심이 되는 성질로 취지에 따라서 로직을 객체에 그룹핑해서 객체라는 부품을 조립해서 소프트웨어라는 완제품을 만들 수 있게 해준다. 


        //모듈
            //모듈이란 : 프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화한다. 그 과정에서 코드의 재활용성을 높이고, 유지보수를 쉽게 할 수 있는 다양한 기법들이 사용된다. 그 중의 하나가 코드를 여러개의 파일로 분리하는 것이다. 이를 통해서 얻을 수 있는 효과는 아래와 같다.
        
            //자주 사용되는 코드를 별도의 파일로 만들어서 필요할 때마다 재활용할 수 있다.
        
            //코드를 개선하면 이를 사용하고 있는 모든 애플리케이션의 동작이 개선된다.
        
            //코드 수정 시에 필요한 로직을 빠르게 찾을 수 있다.
        
            //필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다.
        
            //한번 다운로드된 모듈은 웹브라우저에 의해서 저장되기 때문에 동일한 로직을 로드 할 때 시간과 //네트워크 트래픽을 절약 할 수 있다. (브라우저에서만 해당)

            //순수한 자바스크립트에서는 모듈(module)이라는 개념이 분명하게 존재하지는 않는다. 하지만 자바스크립트가 구동되는 호스트 환경에 따라서 서로 다른 모듈화 방법이 제공되고 있다. 이 수업에서는 자바스크립트의 대표적인 호스트 환경인 웹브라우저에서 로직을 모듈화하는 방법에 대해서 알아볼 것이다.

            //호스트 환경이란 : 호스트 환경이란 자바스크립트가 구동되는 환경을 의미한다. 자바스크립트는 브라우저를 위한 언어로 시작했지만, 더 이상 브라우저만을 위한 언어가 아니다. 예를들어 node.js는 서버 측에서 실행되는 자바스크립트다. 이 언어는 자바스크립트의 문법을 따르지만 이 언어가 구동되는 환경은 브라우저가 아니라 서버측 환경이다. 또 구글의 제품 위에서 돌아가는 Google Apps Script 역시 자바스크립트이지만 google apps script가 동작하는 환경은 구글 스프레드쉬트와 같은 구글의 제품 위이다. 여러분은 자바스크립트의 문법을 이용해서 PHP와 같은 서버 시스템을 제어(node.js)하거나 구글의 제품(Google Apps Script)을 제어 할 수 있다. 지금 당장은 어렵겠지만, 언어와 그 언어가 구동되는 환경에 대해서 구분해서 사고 할 수 있어야 한다. 이를 위해서는 다양한 언어를 접해봐야 한다.

            //모듈의 사용
            //새로운 파일을 만든다. 이름은 greeting.js 다. 자바스크립트 파일은 확장자로 js를 사용한다.
            
            //greeting.js파일에 아래와 같이 함수를 작성한다.
            function welcome(){
                return 'Hello world';
            }

            //그리고 html파일 head태그 안에 아래와 같이 태그를 작성한다.
            <script src="greeting.js"></script>

            //위와 같은 태그는 body태그안에 script태그안에 함수를 작성하는 것과 같다. 그리고 body태그안에 script태그에 alert(welcome());를 쓰면 hello world 라는 경고창이 뜰 것이다.

        
        //라이브러리란 : 모듈과 비슷한 개념이다. 모듈이 프로그램을 구성하는 작은 부품으로서의 로직을 의미한다면 라이브러리는 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합을 의미한다고 할 수 있다. 프로그래밍의 세계에는 휼룡한 라이브러리가 많다. 좋은 라이브러리를 선택하고 잘 사용하는 것은 프로그래밍의 핵심이라고 할 수 있다
    </script>
</body>
</html>