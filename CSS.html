h1 { color: yellow; font-size:2em; }
<!--;은 뒤에 다른 선언이 올 수 있게 사용한다.
    마지막에붙여 쓰지 않아도 되는데 보통 작업 중에 세미콜론이 누락되는 실수를 방지하기 위해서 붙인다
    선택자(selector) - "h1"
    속성(property) - "color", Html속성(attribute)과 css 속성(property)은 다르다
    값(value) - "yellow"
    선언(declaration) - "color: yellow", "font-size: 2em"
    선언부(declaration block) - "{ color: yellow; font-size:2em; }"
    *규칙(rule set) - "h1 { color: yellow; font-size:2em; }"
    css 주석은 /* 주석 내용 */

/*
    주석은 여러 줄로도
    선언 할 수 있습니다.
*/-->

h1
{ color: yellow; font-size:2em;

h1 {
    color: yellow;
    font-size:2em;
}
<!--선택자와 선언부 사이, 선언과 선언 사이는 앞뒤로 개행을 해도 상관이 없습니다.
    하지만 속성이름과 속성값 사이에는 개행을 하면 안 됩니다. -->

<div style="color:red;"> 내용 </div>
<!--inline은 해당 요소에 직접 스타일 속성을 이용해서 규칙들을 선언하는 법
    해당 요소에 직접 입력하기 때문에 선택자는 필요하지 않게 되고,
    선언부에 내용만 스타일 속성의 값으로 넣어주면 됩니다.
    Inline 스타일 방식이라고 부릅니다.
    Inline 스타일 방식은 코드의 재활용이 되지 않기 때문에 자주 사용하지 않습니다.-->

<style> div {color: red;} </style>
<!-- Internal(내부의)은 문서에 <style>을 활용한 방법입니다.
    <style>은 <head>내부에 들어가며 <style>안에 스타일 규칙이 들어갑니다.
    위의 코드로 모든 <div>에 같은 스타일을 줄 수 있습니다.
    하지만 이것도 한계가 있습니다.
    많은 페이지가 있는 경우에는 모든 페이지에 저마다의 규칙을 선언해줘야 합니다.
    페이지가 많고 스타일 규칙 내용이 많아지면 결코 쉬운 일은 아닙니다.-->

div {color: red;}, <link rel="stylesheet" href="css/style.css">
<link rel="stylesheet" href="폰트 경로">
<!--External(외부의)은 외부 스타일 시트 파일을 이용한 방법입니다.
    외부 스타일 시트는 스타일 규칙들을 별도의 외부 파일을 만들어 넣는 방식입니다.
    외부 파일은 확장자가 .css가 되며 css 파일이라고 부릅니다.
    우선 CSS 파일을 하나 만들고 스타일 규칙을 선언합니다.
    그다음 <link>을 이용해서 CSS 파일을 연결하면 됩니다.
    <head> 내부에 <link>를 선언한 후 href 속성을 이용해 CSS 파일의 경로를 적습니다.
    rel 속성은 연결되는 파일이 문서와 어떤 관계인지를 명시하는 속성으로,
    CSS 파일은 'stylesheet' 라고 적어야 합니다.
    외부 스타일 시트 방식으로 스타일을 선언하면 많은 페이지가 있더라도
    이 한 줄로 모든 페이지에 같은 스타일을 적용할 수 있습니다.
    또한, 수정이 필요할 때도 CSS 파일을 수정하면 연결된 모든 페이지에 반영할 수 있습니다.
    외부 스타일 시트 방식은 파일 관리가 편하면서도 용량이 작기 때문에 주로 사용되는 방법입니다.
    link 탭 버튼 이런식으로 작성하면 편하다. font를 불러올때도 link 태그를 사용한다.-->

@import url("css/style.css");
<!-- Import는 스타일 시트 내에서 다른 스타일 시트 파일을 불러오는 방식입니다.
      <style> 내부 상단이나 외부 스타일 시트 파일 상단에 선언하는데 성능상 좋지 않아서 거의 쓰이지 않음
      궁금하면 따로 공부-->


요소 선택자
h1 { color: yellow; }
h2 { color: yellow; }
h3 { color: yellow; }
h4 { color: yellow; }
h5 { color: yellow; }
h6 { color: yellow; }
<!--요소 선택자는 선택자 중에 가장 기본이 되는 선택자이며, 태그 선택자라고도 합니다.
    위 코드처럼 선택자 부분에 태그 이름이 들어갑니다.
    문서 내에 선택자에 해당하는 모든 요소에 스타일 규칙이 적용됩니다.
    <head>에 작성한다.-->

그룹화
h1, h2, h3, h4, h5, h6 { color: yellow; }, * { color: yellow; }
<!--그룹화 선택자는 쉼표를 이용해서 그룹화를 할 수 있습니다.
    전체 선택자 라고 불리는 간단한 선택자도 있습니다.
    *(별표, asterisk) 기호로 문서 내에 모든 요소를 선택할 수 있습니다.
    이렇게 선언하면, 한 번의 선언만으로 문서 내에 모든 요소에 스타일 규칙이 적용됩니다.
    전체 선택자는 매우 편리하지만, 성능에 좋지 않으므로 될 수 있으면 사용을 지양합니다.-->

h1 { color: yellow; font-size: 2em; background-color: gray; }
<!--선택자뿐만 아니라 선언들도 그룹화가 가능합니다.-->
h1, h2, h3, h4, h5, h6 { color: yellow; font-size: 2em; background-color: gray; }
<!--그리고 마지막으로 선택자와 선언이 동시에 그룹화도 가능합니다.-->


class 선택자
.foo { font-size: 30px; } (head에 style태그안에 작성 밑에 모두 동일), <p class="foo"> ... </p>
<!--class 선택자은 요소에 구애받지 않고 스타일 규칙을 적용할 수 있는 가장 일반적인 방법은 class 선택자를 활용하는 것입니다.
    class 선택자를 사용하기 위해서는 HTML을 수정해 class 속성을 추가해야 합니다.
    class 속성은 글로벌 속성이므로 어느 태그에서도 사용할 수 있습니다.
    class 속성에 값을 넣게 되면, class 선택자를 이용해서 해당 요소에 스타일 규칙을 적용할 수 있습니다.-->
<p class="foo"> ... </p>
<!--위 코드처럼 <p>의 class 속성의 값으로 "foo"라는 값을 넣었다면, CSS에서
    그 값("foo")을 선택자로 지정하면 됩니다.
    클래스 선택자를 쓸 때는, 맨 앞에 .(마침표)를 찍어주셔야 합니다.
    이렇게 되면 어느 요소든지 class 속성값이 "foo"로 선언된 요소가 있다면 해당 스타일 규칙을 적용받게 됩니다.-->

다중 class
.foo { font-size: 30px; }<!--style 태그안에 작성-->
.bar { color: blue; }
<!--다중class은 class속성은 꼭 하나의 값만 가질 수 있는 것은 아닙니다.
    공백으로 구분하여 여러 개의 class 값을 넣을 수 있습니다.-->
<p class="foo bar"> ... </p>
<!--위의 <p>에 class 속성에 "foo" 와 "bar" 2개의 값을 넣었습니다.
    그리고 foo class 선택자에는 폰트의 크기를 30px로,
    bar class 선택자에는 글자를 파란색으로 적용하는 스타일 규칙이 선언되어있습니다.
    그렇게 되면 이 <p>에는 2개의 규칙이 모두 적용이 됩니다.-->

id선택자
#bar { background-color: yellow; }
<p id="bar"> ... </p>
<!--id 선택자는 class 선택자와 비슷합니다.
    선택자를 쓸 때는, .(마침표) 기호 대신 #(해시) 기호를 써주시면 되고,
    요소에는 class 속성 대신 id 속성만 써주면 됩니다. -->
<!--class 선택자와의 차이점
    .기호가 아닌 #기호 사용
    태그의 class 속성이 아닌 id 속성을 참조
    문서 내에 유일한 요소에 사용 (중복 X)
    구체성
    가장 큰 차이점은 class와 달리 id는 문서 내에서 유일해야 한다는 점입니다.
    클래스 선택자는 여러 요소에 같은 클래스를 넣고 같은 규칙을 적용 할 수 있었습니다.
    그리고 그것이 클래스 선택자의 장점이기도 합니다.
    하지만 id 속성값은 문서 내에 유일하게 사용이 되어야 합니다.
    결국, id 선택자로 규칙을 적용할 수 있는 요소는 단 하나뿐입니다.
    우선순위 id>class-->


선택자의 조합
/* 요소와 class의 조합 */
p.bar { ... }
<!--이 경우에는 <p>이면서 class 속성에 bar가 있어야 적용됩니다.-->

/* 다중 class */
.foo.bar { ... }
<!--다중 클래스의 경우  class 속성에 foo와 bar가 모두 있어야 적용됩니다. -->

/* id와 class의 조합 */
#foo.bar { ... }
<!--이 경우에는 id가 foo이며 class가 bar인 요소에 적용됩니다.-->

속성 선택자 <!--대괄호를 이용해서 선언하며 대괄호 안에 속성 이름이 들어갑니다.-->
1. 단순 속성으로 선택
p[class] { color: silver; }
p[class][id] { text-decoration: underline; }
<p class="foo">Hello</p>
<p class="bar">CSS</p>
<p class="baz" id="title">HTML</p>
<!-- 요소에 해당 이름의 속성이 있다면 해당 사항이 적용됩니다.
    위 CSS 코드는 요소 선택자와의 조합으로 이루어진 코드입니다.
    첫 번째는 <p>이면서 class 속성이 있는 요소이면 color: silver 규칙이 적용됩니다.
    두 번째는 <p>이면서 class 속성과 id 속성이 함께 있어야 text-decoration: underline 규칙이 적용됩니다.
    바로 위  HTML 코드에는 3개의 <p>가 있습니다.
    그렇다면 이 3개의 <p>에는 각자 어떤 스타일이 적용될까요?
    먼저 예측을 하시고 직접 실습을 하는 게 좋습니다.
    p[class] 선택자의 규칙은 class 속성만 존재하면 적용이 되기 때문에 3가지 요소 모두에 적용됩니다.
    p[class][id] 선택자의 규칙은 class 속성과 id 속성 모두 있는 요소만 해당하기 때문에 마지막 요소에만 적용됩니다.
    두 규칙 모두 속성의 값은 상관하지 않습니다.-->

2.정확한 속성값으로 선택
p[class="foo"] { color: silver; }
p[id="title"] { text-decoration: underline; }
<!--제목 그대로 속성의 값으로 요소를 선택합니다.
    선택자는 대괄호 안에 속성 이름과 속성값을 다 적으면 됩니다.
    p[class="foo"]는 <p>이면서 class 속성의 값이 foo이면 적용되고,
    p[id="title"]는 <p> 이면서 id 속성의 값이 title이면 적용됩니다.-->

3.부분 속성값으로 선택
p[class~="color"] { font-style: italic; } /* 1, 2번째 요소 */
p[class^="color"] { font-style: italic; } /* 1, 3번째 요소 */
p[class$="color"] { font-style: italic; } /* 2번째 요소 */
p[class*="color"] { font-style: italic; } /* 1, 2, 3번째 요소 */
<p class="color hot">red</p>
<p class="cool color">blue</p>
<p class="colorful nature">rainbow</p>
<!--부분 속성값으로 선택은 속성 이름과 속성값 사이에 사용되는 기호에 따라 동작이 조금 다릅니다.
    [class~="bar"] : class 속성의 값이 공백으로 구분한 "bar" 단어가 포함되는 요소 선택
    [class^="bar"] : class 속성의 값이 "bar"로 시작하는 요소 선택
    [class$="bar"] : class 속성의 값이 "bar"로 끝나는 요소 선택
    [class*="bar"] : class 속성의 값이 "bar" 문자가 포함되는 요소 선택-->

부모와 자식
    <html>
    <body>
        <div>
            <h1><span>HTML</span>: Hyper Text Markup Language</h1>
        </div>
        <p class="AA">HTML과 CSS와 JAVASCRIPT를 이용해서 멋진 웹 사이트를 제작할 수 있습니다.</p>
        <p></p>
        <P></p>
    </body>
    </html>
<!--<body>의 부모 요소: <html> ↔ <html>의 자식 요소: <body>
    <div>의 부모 요소: <body> ↔ <body>의 자식 요소: <div>, <p>
    <h1>의 부모 요소: <div> ↔ <div>의 자식 요소: <h1>
    <span>의 부모 요소: <h1> ↔ <h1>의 자식 요소: <span>
    <p>의 부모 요소: <body> ↔ <body>의 자식 요소: <div>, <p>-->
조상과 자손
<!--<body>의 조상 요소: <html> ↔ <html>의 자손 요소: <body>, <div>, <h1>, <span>, <p>
    <div>의 조상 요소: <html>, <body> ↔ <body>의 자손 요소: <div>, <h1>, <span>, <p>
    <h1>의 조상 요소: <html>, <body>, <div> ↔ <div>의 자손 요소: <h1>, <span>
    <span>의 조상 요소: <html>, <body>, <div>, <h1> ↔ <h1>의 자손 요소: <span>
    <p>의 조상 요소: <html>, <body> ↔ <body>의 자손 요소: <div>, <h1>, <span>, <p>-->
형제
<!--같은 부모를 가지고 있는 요소들은 서로 형제 관계에 있습니다.
    위 코드에서는 <div>, <p>가 형제 요소입니다.
    형제 관계 중에는 인접한 관계도 있습니다.
    형제 관계에 있는 요소 중 바로 뒤에 이어 나오는 요소를 인접해 있다고 합니다.
    여기서 <p>가 <div>에 인접한 형제 요소가 됩니다.-->

문서 구조 관련 선택자
1.자손 선택자
div span { color: red; }
<!--자손 선택자는 선택자 사이에 아무 기호없이 그냥 공백으로 구분을 합니다.
    이 선택자는 <div>의 자손 요소인 <span>를 선택하는 선택자 입니다.-->

2. 자식 선택자
div > h1 { color: red; }
<!--자식 선택자는 선택자 사이에 닫는 꺽쇠 기호(>)를 넣습니다.
    꺽쇠 기호와 선택자 기호 사이에는 공백은 있거나 없어도 상관이 없습니다.
    이 선택자는 <div>의 자식 요소인 <h1>를 선택하는 선택자 입니다.-->

3. 인접 형제 선택자
div + p { color: red; }
<!--인접 형제 선택자는 선택자 사이에 + 기호를 넣습니다.
    자식 선택자와 마찬가지로 공백은 있거나 없어도 상관이 없습니다.
    인접 형제 선택자는 형제 관계이면서 바로 뒤에 인접해 있는 요소를 선택하는 선택자입니다. -->

4. 기준인 형제 요소 다음에 오는 형제들 선택자
AA ~ p {color: red; }
<!--AA 기준으로 다음에 오는 형제들 다 글자색 레드로 적용-->

ex) body > div table + ul { ... }
<!--/* body 요소의 자식인 div 요소의 자손인 table 요소 바로 뒤에 인접한 ul 요소 선택! */-->


가상 클래스
<!--가상 클래스는 미리 정의해놓은 상황에 적용되도록 약속된, 보이지 않는 클래스입니다.
    우리가 직접 요소에 클래스를 선언하는 것은 아니고, 약속된 상황이 되면 브라우저 스스로 클래스를 적용해줍니다.
    예를 들어, <p>가 있다고 가정하겠습니다.
    이 <p>에 마우스 커서를 올렸을 때만 특정 스타일을 주고 싶다고 한다면 어떻게 해야 할까요?
    가상 클래스가 없다면 이런 과정을 거치게 됩니다.
    1.임의의 클래스 선택자를 선언하여 특정 스타일 규칙을 만든다.
    2.p 요소에 커서가 올라가면 p 요소에 클래스를 집어넣는다.
    3.p 요소에서 커서가 빠지면 p 요소에 클래스를 삭제한다.
    여기서 2, 3번은 동적으로 변화되어야 하는데, HTML과 CSS는 정적인 언어이기 때문에 처리할 수 없습니다.
    어쩔 수 없이 다른 언어를 사용해야 하는데, 이는 개발 비용이 들어가는 일입니다.
    그래서 CSS에서는 흔하게 사용되는 여러 패턴에 대해서 미리 정의해놓고, 가상 클래스로 제어할 수 있게 했습니다.-->
:pseudo-class {
    property: value;
}
<!--위처럼 가상 클래스는 :(콜론) 기호를 써서 나타냅니다.
    가상 클래스를 이용하면 아래의 경우에도 CSS만으로 처리가 가능하므로 훨씬 효율적입니다.
    ":hover 가상 클래스 선택자를 이용해서 스타일 규칙을 만든다. (hover는 마우스 커서가 올라갔을 때 적용이 되도록 정의되어 있습니다.)"
    가상 클래스에는 여러 가지가 있습니다.
    이 수업에서는 가장 기초적이고 대표적인 가상 클래스만을 설명해 드리기 때문에 아래 링크를 참고 직접 공부하시길 바랍니다.
    https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-classes-->

  1.문서 구조와 관련된 가상 클래스
  <!--문서 구조와 관련된 가상 클래스는 first-child와 last-child, nth-child()가상 클래스 선택자 입니다.-->
    li:first-child { color: red; }
    li:last-child { color: blue; }
    <ul>
        <li>HTML</li>
        <li>CSS</li>
        <li>JS</li>
    </ul>
    <!--:first-child  첫 번째 자식 요소 선택
    :last-child  마지막 자식 요소 선택
    :nth-child(n번째) n번째 자식 요소 선택
    첫 번째 <li>와 마지막 <li>에 가상 클래스가 적용됩니다.
    실제 <li>에는 class 속성이 없지만 내부적으로 가상 클래스가 적용되어
    마치 아래의 코드와 같이 동작하게 됩니다.
    html 실습 참고-->
    <ul>
        <li class="first-child">HTML</li>
        <li>CSS</li>
        <li class="last-child">JS</li>
    </ul>

2.앵커 요소와 관련된 가상 클래스
<!--앵커 요소와 관련된 가상 클래스로는 :link와 :visited가 있습니다.-->
a:link { color: blue; }
a:visited { color: gray; }
<!--:link : 하이퍼 링크이면서 아직 방문하지 않은 앵커
    :visited : 이미 방문한 하이퍼링크를 의미
    하이퍼 링크는 앵커 요소에 href 속성이 있는 것을 의미합니다.-->

3.사용자 동작과 관련된 가상 클래스
a:focus { background-color: yellow; }
a:hover { font-weight: bold; }
a:active { color: red; }
<!--이 클래스들도 <a>에 주로 많이 쓰입니다.
    <a>에만 쓸 수 있는 것은 아니며, 이 조건에 맞는 상황이 되는 요소들은 다 사용이 가능합니다.
    :focus 현재 입력 초점을 가진 요소에 적용
    :hover 마우스 포인터가 있는 요소에 적용
    :active 사용자 입력으로 활성화된 요소에 적용

    focus(초점)는 지금 현재 선택을 받는 것을 의미합니다.
    예를 들면, 입력 폼 요소에 텍스트를 입력하려고
    마우스 클릭해서 커서를 입력 폼 위에 올려놓으면 그때 입력 폼 요소가 초점을 받는 상태입니다.
    또 키보드의 탭 키를 이용해서 요소를 탐색하다 보면
    링크나 버튼에 점선 테두리가 이동하는 것을 볼 수 있는데,
    점선 테두리가 위치하는 것도 초점을 받은 상태입니다.

    :hover는 마우스 커서가 있는 요소에 적용됩니다. (마우스를 올렸을 때를 의미합니다.)

    :active는 사용자 입력으로 활성화된 요소를 의미하는데,
    <a>를 클릭할 때 또는 <button>를 눌렀을 때처럼 순간적으로 활성화됩니다.-->

    <!-- :focus와 :active는 엄밀히 말하면 다른 상태이긴 하지만
    focus는 active를 포함을 하는, 아주 미묘한 관계입니다.
    focus: 요소가 포커스 되었을 때 (active 상태도 포커스 상태의 일부)
    active: 요소를 마우스로 클릭하는 찰나의 순간

    그렇기 때문에

 input:focus {
 }

 input:active {
 }
    이 순서로 하시면 active 스타일이 적용이 되실 거예요.
    왜냐하면 focus 상태일 때의 스타일을 기본으로 깔고,
    active 상태일 때 추가로 스타일을 추가해 "덮어주는 것"이니까요! -->

가상 요소
::pseudo-element {
    property: value;
}
<!--가상 요소는 HTML 코드에 존재하지 않는 구조 요소에 스타일을 부여할 수가 있습니다.
    가상 요소도 가상 클래스처럼 문서 내에 보이지 않지만, 미리 정의한 위치에 삽입되도록 약속이 되어있습니다.
    선언 방법은 가상 클래스와 같게 콜론을 사용하며,
    CSS3부터는 가상 클래스와 가상 요소를 구분하기 위해 가상 요소에는 ::(더블 콜론) 기호를 사용하기로 했습니다.
    하지만 하위 브라우저에서 :: 문법을 지원하지 않는 문제가 있으므로 상황에 따라 : 기호를 사용하셔야 합니다.
    다른 가상 요소들에 대한 자세한 내용은 아래 링크를 참고해주세요.
    https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements-->
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
p::before { content: "###" }
p::after { content: "!!!" }
p::first-line { ... }
p::first-letter { ... }
<!--::before : 가장 앞에 요소를 삽입
    ::after : 가장 뒤에 요소를 삽입
    ::first-line : 요소의 첫 번째 줄에 있는 텍스트
    ::first-letter : 블록 레벨 요소의 첫 번째 문자
    before와 after 가상 요소는 애초에 내용이 없는 상태로 생성되기 때문에 내용을 넣기 위해
    content 속성을 이용해야 합니다.(content안에 값이 없으면 cnotent:""으로 둔다, 필수로 써야함)
    실제 HTML 코드에는 나타나지 않지만,
    before와 after가 어떻게 동작하는지 이해를 돕기 위해 코드를 아래와 같이 변경했습니다.-->
<p>
  <before>###</before>
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
  <after>!!!</after>
</p>

<!--눈에 보이지 않지만, 내부에서 이처럼 요소가 생성됩니다.
    first-line과 first-letter도 마찬가지로 아래 코드와 같은 것으로 생각하시면 됩니다.-->
<p>
<first-letter>L</first-letter>orem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.
</p>
<p>
<!-- 모니터 가로 해상도에 따라 요소가 포함하는 내용이 변동됩니다. -->
<first-line>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiu ..(..어딘가쯤..) </first-line>... unt ut labore et dolore magna aliqua.
</p>


구체성
<!--요소를 선택하는 데는 여러 방법이 있습니다.
    따라서 서로 다른 선택자를 이용해 같은 요소를 선택할 수도 있습니다.
    만약 같은 요소를 선택하는 서로 다른 규칙들이 상반된 스타일을 가지고 있다면 어떻게 표현이 될까요?-->
h1 { color: red; }
body h1 { color: green; }
<!--두 규칙은 모두 <h1>을 선택하게 됩니다.
    하지만 두 규칙이 지정하는 스타일은 서로 다릅니다.
    그렇다면 <h1>은 어떻게 표현이 될까요?
    <h1>에는 color: green이 적용되는데 이는 구체성과 연관이 있습니다.
    선택자에는 어떤 규칙이 우선으로 적용되어야 하는지에 대해 정해진 규칙이 있습니다.
    이 규칙을 '구체성'이라고 합니다.
    구체성은 선택자를 얼마나 명시적으로(구체적으로) 선언했느냐를 수치화한 것으로,
    구체성의 값이 클수록 우선으로 적용이 됩니다.-->

0, 0, 0, 0
<!--위와 같이 구체성은 4개의 숫자 값으로 이루어져 있습니다.
    값을 비교할 때는 좌측에 있는 값부터 비교하며, 좌측 부분의 숫자가 클수록 높은 구체성을 갖습니다.
    구체성은 아래의 규칙대로 계산됩니다.
    0, 1, 0, 0 : 선택자에 있는 모든 id 속성값
    0, 0, 1, 0 : 선택자에 있는 모든 class 속성값, 기타 속성, 가상 클래스
    0, 0, 0, 1 : 선택자에 있는 모든 요소, 가상 요소
    전체 선택자는 0, 0, 0, 0을 가진다.
    조합자는 구체성에 영향을 주지 않는다. (>, + 등)-->
h1 { ... }  /* 0,0,0,1 */
body h1 { ... }  /* 0,0,0,2 */
.grape { ... }  /* 0,0,1,0 */
*.bright { ... }  /* 0,0,1,0 */
p.bright em.dark { ... }  /* 0,0,2,2 */
#page { ... }  /* 0,1,0,0 */
div#page { ... }  /* 0,1,0,1 */
<!--선택자의 구체성 값을 잘 알아야 많은 스타일 규칙들을 정의할 때 의도하지 않은 일이 생기지 않습니다.-->

인라인 스타일
<!--지금까지 선택자의 구체성에 대해 살펴봤습니다.
    그렇다면 인라인 스타일로 선언된 경우에는 어떻게 될까요?-->
p#page { color: red; }
<p id="page" style="color:blue">Lorem impusm dolor sit.</p>
<!--첫 번째는 0, 1, 0, 1의 구체성을 가지는 선택자로 스타일을 선언했고,
    두 번째는 요소에 직접 인라인 스타일 방식으로 스타일을 선언했습니다.
    결과적으로 <p>에는 color: blue가 적용됩니다.
    인라인 스타일의 구체성 값은 1, 0, 0, 0이며 규칙들 중 가장 큰 구체성을 갖기 때문입니다.-->

important
<!--important 키워드는 별도의 구체성 값은 없지만, 모든 구체성을 무시하고 우선권을 갖습니다.
    important 키워드는 속성값 뒤 한 칸 공백을 주고 느낌표 기호와 함께 씁니다.-->
p#page { color: red !important; }
<p id="page" style="color:blue">Lorem impusm dolor sit.</p>
<!--위의 <p>에는 important로 인해 color: red가 적용됩니다.-->


상속되는 속성
h1 { color: gray; }
<h1>Hello, <em>CSS</em></h1>
<!--위 코드에서 <em>은 부모인 <h1>의 color: gray를 상속받습니다.
    상속은 자연스러운 현상처럼 보이지만, 모든 속성이 다 상속되는 것은 아닙니다.
    아직 속성에 대해 다 배우지는 않았지만,
     margin, padding, background, border 등 박스 모델 속성들은 상속되지 않는다는 것을 알고 계시면 됩니다.
    상속되는 속성들은 보통 상식적으로 구분될만한 속성들이며,
    후에 속성들에 대해 배우게 되면 자연스럽게 이해할 수 있습니다.-->

상속되는 속성의 구체성
* { color: red; }
h1#page { color: gray; }
<h1 id="page">Hello, <em>CSS</em></h1>
<!--위 코드에서는 전체 선택자를 이용해 color: red를 적용하고 id 선택자를 이용해 color: gray를 선언했습니다.
    전체 선택자의 구체성은 0, 0, 0, 0 이며 id 선택자의 구체성은 0,1,0,1 입니다.
    그렇다면 <em>에는 어떤 color가 적용될까요?
    color: red가 적용되는데 그 이유는 바로 상속된 속성은 아무런 구체성을 가지지 못하기 때문입니다.-->


앞서 배운 구체성은 cascading 규칙 중 하나입니다.
만약 구체성이 같은 두 규칙이 동일한 요소에 적용된다면 어떻게 될까요?
h1 { color: red; }
h1 { color: blue; }
<!--위 <h1>에는 같은 구체성을 가진 두 규칙이 적용되었습니다.
    그렇다면 <h1>에는 어떤 color가 적용될까요?
    <h1>에는 color: blue가 적용되며 이는 cascading 규칙에 의해 적용된 결과입니다.
    cascading에는 다음과 같이 3가지 규칙이 있습니다.
    1.중요도(!important)와 출처
    2.구체성
    3.선언 순서
    위에서의 출처는 CSS 출처를 의미합니다.(=<link href="" alt="">)
    CSS 출처는 제작자와 사용자, 그리고 사용자 에이전트(user agent) 경우로 구분합니다.
    제작자의 경우는 사이트를 실제 제작하는 개발자가 작성한 CSS를 의미합니다. (대부분이 여기에 해당합니다.)
    그리고 사용자의 경우는 웹 페이지를 방문하는 일반 사용자들이 작성한 CSS를 의미합니다.
    마지막으로 사용자 에이전트의 경우는 일반 사용자의 환경, 즉 브라우저에 내장된 CSS를 의미합니다.
    우선 순위 \1.사용자 !important 스타일(거의 사용을 잘안함)
              2.제작자 !important 스타일
              3.제작자 스타일
              4.사용자 스타일(일반 유저가 직접 css를 만들어서
              본인 브라우저에 설정, 잘 사용하지도 않고, 지원하지 않는 브라우저도 있어 잘 사용안함)
              5.사용자 에이전트 스타일
    현재의 브라우저에서는 사용자 스타일을 지원하지 않는 추세이기 때문에 이와 관련해서는 생략하도록 하겠습니다.
    스타일이 적용되는 방식은 생각보다 간단합니다.
    모든 스타일은 아래의 규칙에 따라 단계적으로 적용됩니다.
  1.스타일 규칙들을 모아서 중요도가 명시적으로 선언되었는지에 따라 분류합니다.
    1.중요도가 명시적으로 선언된 규칙들은 그렇지 않은 규칙들보다 우선합니다.
    2.중요도가 있는 규칙들끼리는 아래 다른 규칙들을 적용받습니다.
  2.스타일 규칙들을 출처에 따라 분류합니다.
    1.제작자 스타일 규칙이 사용자 에이전트 스타일 규칙보다 우선합니다.
  3.스타일 규칙들을 구체성에 따라 분류합니다.
    1.구체성이 높은 규칙들이 우선합니다.
  4.스타일 규칙들을 선언 순서에 따라 분류합니다.
    1.뒤에 선언된 규칙일수록 우선합니다.-->
<p id="bright">Hello, CSS</p>
p#bright { color: silver; }
p { color: red; }
<!--위의 경우에는 구체성에 따라 color: silver가 적용됩니다.-->
p { color: silver; }
p { color: red; }
<!--위의 경우에는 선언 순서에 따라 color: red가 적용됩니다.-->


절대 길이(font-size은 상속가능, 대부분의 브라우저에서 폰트 크기의 디폴트 값은 16px이다,크롬은 최소 사이즈가 10px이다)
<!--절대 길이는 고정된 크기 단위로, 다른 요소의 크기에 의해 영향을 받지 않습니다.-->
px ( 1px = 1/96th of 1 inch )
<!--절대 길이이므로 다른 요소의 영향을 받지 않아 화면에서 고정된 크기를 가지지만, 장치의 해상도에 따라 상대적입니다.
    여러 환경에서 디자인을 같게 표현하고 브라우저 호환성에 유리한 구조로 되어 있어서,
    디자인 의도가 많이 반영된 웹사이트의 경우 픽셀 단위를 사용하는 것을 권장하고 있습니다.-->
pt ( 1pt - 1/72 of 1 inch )
<!--컴퓨터가 없던 시절부터 있던 단위입니다.
    인쇄물이나 워드프로세서 프로그램에서 사용된 가장 작은 표준 인쇄단위입니다.
    웹 화면에 인쇄용 문서를 위한 스타일을 적용할 때 유용하게 사용할 수 있습니다.
    그러나 사용하는 기기의 해상도에 따라 차이가 있어 W3C에서도 pt는 웹개발 시 권장하는 단위가 아닙니다.
    예를 들면 Windows에서는 9pt = 12px, Mac에서는 9pt = 9px 로 보이게 됩니다.-->

상대 길이<!--상대 길이는 다른 요소의 크기나 폰트 크기, 브라우저(viewport) 등의 크기에 따라 상대적으로 값이 변합니다.-->
%
<!--부모의 값에 대해서 백분율로 환산한 크기를 갖게 됩니다.-->
em
<!--font-size 부모값를 기준으로 값을 환산(값에 곱)합니다. 소수점 3자리까지 표현 가능합니다.-->
rem
<!--root(최상위)의 font-size를 기준으로 값을 환산(값에 곱)합니다.-->
vw
<!--뷰포1200x1000의 width(1200)값을 기준으로 1%의 값으로 계산됩니다.-->


Color 속성
h1  {color: 색상 값;}
<!--폰트의 색상 값을 적용할 때 사용하는 속성입니다. -->

색상 값 지정 방식
1.컬러 키워드
<!--CSS 자체에서 사용 가능한 문자 식별자입니다.
    red, blue, black 등과 같이 미리 정의되어있는 키워드를 이용해 색상을 표현할 수 있습니다.
    *참고 : transparent는 투명을 나타내는 키워드*-->
2.16 진법  ex)#RRGGBB
<!--6자리의 16진수(0-9, A-F)는 각각 두 자리씩 세 가지 색상을 나타냅니다.
    첫 번째 두 자리는 적색(RR), 가운데 두 자리는 녹색(GG), 마지막 두 자리는 청색(BB)을 의미합니다.
    각 자리의 알파벳은 대소문자를 구분하지 않습니다.-->
3.RGB( )
<!--RGB 값은 rgb(R, G, B)의 형태로 각 변수 값(R 적색, G 녹색, B 청색)의 강도를 정의합니다.
    0~255의 정수로 된 값을 지정할 수 있으며, 0 → 255는 검정 → 흰색으로 값의 변화를 나타냅니다.-->
4.RGBA( )
<!--RGBA 값은 기존 RGB에서 A값이 추가된 형태입니다.
    rgb(R, G, B, A)의 형태로 각 변수는(R 적색, G 녹색, B 청색, A 투명도)의 강도를 정의합니다.
    A 값은 0 ~ 1 사이의 값을 지정할 수 있으며, 0.5와 같이 소수점으로 표기합니다.
    0 → 1은 투명 → 불투명으로 값의 변화를 나타냅니다.
    예를 들어, rgba( 0, 0, 0, 0)는 투명한 색상을 가지게 됩니다.-->


background 관련 속성
  background-color : (색상)
  기본 값 : transparent
<!--배경의 색상을 지정하는 속성입니다.
    앞선 색상 강의에서 배운 색상 값 적용 방식과 같습니다.-->

  background-image :url(경로)
  기본 값 :  none
<!--배경으로 사용할 이미지의 경로를 지정하는 속성입니다.
    url의 경로는 절대 경로, 상대 경로 모두 사용 가능합니다.
    만약 background-color에 색상이 적용된 상태에서 background-image로 사용된 이미지에 투명한 부분이 있다면,
    그 부분에 background-color 색상이 노출됩니다.-->

  background- repeat : 값
  기본 값 : repeat
<!--이미지의 반복 여부와 방향을 지정하는 속성입니다.
    기본값이 repeat이기 때문에 따로 설정하지 않으면 x, y축으로 반복되어서 표시됩니다.
    background-repeat의 값으로 사용할 수 있는 것들은 다음과 같습니다.
    repeat :  x, y축 으로 모두 반복합니다.
    repeat-x : x 축 방향으로만 반복합니다.
    repeat-y : y 축 방향으로만 반복합니다.
    no-repeat : 이미지를 반복하지 않습니다. -->

  background-position : 값
  기본 값 : 0%  0%
<!--기본 값 : 0%(X축)  0%(y축) 요소에서 배경 이미지의 위치를 지정하는 속성입니다.
    x축, y축으로부터의 위치를 지정할 수 있으며, 값의 선언 순서는 x축, y축으로부터의 간격입니다.
    만일 한쪽만 지정된다면 나머지는 중앙 값(center)으로 적용됩니다.
    < 속성 값 >
    % : 기준으로부터 % 만큼 떨어진 지점과 이미지의 % 지점이 일치하는 곳에 위치시킵니다.
    px : 기준(상단의 왼쪽 이미지의 끝 점)으로부터 px 만큼 떨어진 지점과
          이미지의 (0,0)= 지점이 일치하는 곳에 위치시킵니다.
    키워드 : top, left, right, bottom, center 키워드를 사용할 수 있습니다.
    키워드는 : 선언 순서와 관계없이 top, bottom은 y축 기준으로 하며 left, right는 x축을 기준으로 합니다.-->

  background-attachment : 값
기본 값 : scroll
<!--< 속성 값 >
    scroll : 배경 이미지는 요소 자체를 기준으로 고정되어 있으며 내용과 함께 스크롤 되지 않습니다.
    local : 배경 이미지는 요소의 내용을 기준으로 고정되어 있으며 내용과 함께 스크롤 됩니다.
    fixed : 배경 이미지는 뷰포트를 기준으로 고정되어 있으며 스크롤에 영향을 받지 않습니다.
    - 뷰포트 : 사용자가 시각적으로 볼 수 있는 웹페이지 영역을 의미합니다.
      컴퓨터나 휴대폰과 같은 장치에 Display 요소가 표현되는 영역을 말합니다.-->

background-size : 값
<!-- < 속성 값 >
contain : 이미지가 기본크기를 유지하고 있는 박스크기에 맞게 표시
cover: 이미지의 기본 크기상태에서 박스요소에 포함
custom: 숫자값으로 표현(%,px,top,bottom 등)-->

background 축약
background: [-color] [-image] [-repeat] [-attachment] [-position];
<!-- 선언순서 상관없이 적용됨-->


overflow
 <!--"내용" 이 지정된 영역을 벗어났을때 처리방법을 설정합니다.
    -벗어난 부분을 그냥 보이지 않게 하거나
    -스크롤바를 달아서 볼수 있게 하거나
    -스크롤바를 상황에 맞게 자동으로 보이도록
    설정할 수 있습니다 -->
overflow 의 3가지 속성
<!--visible: 기본값 벗어난 부분을 보여주게 하는 값
    -hidden 내용이 많아서 영역을 넘어간 부분은 숨깁니다.
    -scroll 내용과 상관없이 무조건 스크롤바를 만듭니다.
    -auto 내용이 넘어갈때 만 자동으로 스크롤바를 만듭니다. -->

overflow-x,-y
<!--overflow 에서 가로(x), 세로(y)설정만 특화된 것입니다. 속성은 위와 동일 -->


문서를 배치할 때 브라우저의 렌더링 엔진은 표준 CSS 기본 박스 모델에 따라 각 요소를 사각형 상자로 나타냅니다 .
CSS를 이용해 이 상자의 크기, 위치 및 속성(색상, 배경, 테두리 크기 등)을 변경할 수 있습니다.
boxmodel 구성.PNG 참고
<!-- 1.Content 영역
      요소의 실제 내용을 포함하는 영역입니다. 따라서 크기는 내용의 너비 및 높이를 나타냅니다.

    2.Border 영역
      content 영역을 감싸는 테두리 선을 border라고 합니다.

    3.Padding 영역
      content 영역과 테두리 사이의 여백을 padding이라고 합니다.
      content 영역이 배경, 색 또는 이미지가 있을 때 패딩 영역까지 영향을 미칩니다.
      이에 따라 padding을 content의 연장으로 볼 수도 있습니다.

    4.Margin 영역
      border 바깥쪽의 영역을 margin이라고 합니다.
      border 영역을 다른 요소와 구별하기 위해 쓰이는 빈 영역입니다.
      즉, 주변 요소와의 여백(간격)을 margin을 이용해 지정할 수 있습니다.-->


border 관련 속성
border 축약
border: [-width] [-style] [-color];
<!--위와 같이 공백으로 구분해 축약하여 사용할 수 있고, 정의되지 않은 속성값에 대해서는 기본값이 적용됩니다.
    선언순서는 상관없이 적용됨-->

1.border-width
border-width: [top] [right] [bottom] [left];= 시계방향순
<!--기본 값 : medium
    선의 굵기를 지정하는 속성입니다.
    border-top-width, border-bottom-width, border-right-width, border-left-width를
    이용하여 상하좌우 선의 굵기를 다르게 표현할 수 있습니다.
< 속성 값 >
    키워드 : thin, medium, thick
    단위 : px, em, rem ... ( % , 정수 단위 사용불가 )-->

2. border-style
border-style: [top] [right] [bottom] [left];= 시계방향순
<!--border-style 기본 값 :  none
    선의 모양을 지정하는 속성입니다.
    border-top-style, border-bottom-style, border-right-style, border-left-style을
    이용하여 상하좌우 선의 모양을 다르게 표현할 수 있습니다.
    또한, 위처럼 축약하여 공백을 이용해 각 방향에 대한 스타일을 지정할 수도 있습니다.
< 속성 값 >
    none : border를 표시 하지 않습니다.
    solid : border를 실선 모양으로 나타냅니다.
    double(두배) : border를 이중 실선 모양으로 나타냅니다.
    dotted : border를 점선 모양으로 나타냅니다.
    그 밖에도 dashed(직사각형 점선),groove(테두리가 파인 것처럼 그립), ridge(테두리가 튀어나온 것처럼 그림),
    inset(요소가 파인 것처럼 테두리를 그림), outset(요소가 튀어나온 것처럼 그림) 등의 다양한 스타일이 있습니다.-->

3.border-color
border-color: [top] [right] [bottom] [left];= 시계방향순
<!--border- color 기본 값 : currentColor 선의 색상을 지정하는 속성입니다.
    border-top-color, border-bottom-color, border-right-color, border-left-color를
    이용하여 상하좌우 선의 색상을 다르게 표현할 수 있습니다.
    또한, 위처럼 축약하여 공백을 이용해 각 방향의 색상을 지정할 수도 있습니다.
    색상은 일반적인 CSS 색상 값 사용 방식과 같습니다-->

4.border-radius:4px;
<!--border-radius은 박스가 둥글어지는 속성이다 -->
 border-top-left:4px;
 <!-- 위에 처럼 위치에 따라 동글게 설정할 수 있음.
      값으로는 px,%...등등-->


padding 속성
<!-- = 기본값:0
<!-- < 속성 값 >
    length : 고정값으로 지정합니다. (ex. px, em ....)
    percent : 요소의 width에 상대적인 크기를 지정합니다.
    padding-top content : 영역의 위쪽 여백을 지정합니다.
    padding-right content : 영역의 오른쪽 여백을 지정합니다.
    padding-bottom content : 영역의 아래쪽 여백을 지정합니다.
    padding-left content : 영역의 왼쪽 여백을 지정합니다.-->

Syntax
padding: [-top] [-right] [-bottom] [-left];
            0      10px     20px      30px   /* 상, 우, 하, 좌 다름 */
            0      10px     20px             /* 좌, 우 같음 */
            0      10px                      /* 상, 하 같음 & 좌, 우 같음 */
            0                                /* 상, 우, 하, 좌 모두 같음 */
<!-- 기본적으로 padding의 4가지 속성을 위와 같이 축약하여 사용할 수 있습니다.
      속성의 순서는 고정되어있으며, 위쪽을 기준으로 시계방향으로 돌아간다고 생각하면 쉽습니다.
      축약형으로 사용할 때 반드시 4개의 속성에 대한 값을 모두 적어야 하는 것은 아닙니다.
      속성값은 1~4개의 값을 사용할 수 있으며 border에서는 축약형 사용 시 정의되지 않은
      속성값에 대해서 기본값이 적용되었지만, padding은 조금 다른 방식으로 동작합니다.
      그 이유는 상하, 좌우 영역의 값이 같을 때 하나로 합쳐서 적용할 수도 있기 때문입니다.  -->
<!--
      padding : 20px 30px 40px 30px 일 때, 좌우의 패딩 값이 같을 때
      padding : 20px 30px 40px 와 같이 함축하여 사용할 수 있습니다.

      padding : 20px 30px 20px 일 때, 좌우 패딩과 마찬가지로 상하의 패딩 값이 같을 때
      padding : 20px 30px 와 같이 함축하여 사용 할 수 있습니다.

      padding : 20px 20px ( = 20px, 20px, 20px, 20px )일 때,
      상하좌우 패딩 값이 모두 같을 때 padding : 20px 와 같이 하나의 값으로 함축하여 사용할 수 있습니다. -->
<!-- * 참고 : CSS에서 0 값에 대해서는 단위를 따로 적지 않습니다.
        0px = 0% = 0em = 0pt...  =>   "  0 " -->


margin 속성
<!-- 기본값 : 0 -->
<!-- < 속성 값 >
length : 고정값으로 지정합니다. (ex. px, em ....)
percent : 요소의 width에 상대적인 크기를 지정합니다.
auto : 브라우저에 의해 계산된 값이 적용 됩니다. -->

syntax(컴퓨터 언어의 문법)
margin: [-top] [-right] [-bottom] [-left];
          0      10px     20px      30px   /* 상, 우, 하, 좌 다름 */
          0      10px     20px             /* 좌, 우 같음 */
          0      10px                      /* 상, 하 같음 & 좌, 우 같음 */
          0                                /* 상, 우, 하, 좌 모두 같음 */
<!--padding과 마찬가지로 축약하여 사용할 수 있고, 상하, 좌우에 대해서 값이 같으면 하나로 합하여 사용할 수 있습니다.
    margin에서는 수치 이외에 사용할 수 있는 'auto' 값이 있습니다. -->

margin auto
<!--margin auto은 가로축 중앙 정렬(요소에 width 값 필요)
    기본적으로 브라우저에 의해 계산이 이루어지는데,
    대부분의 경우 0(기본값) 또는 요소의 해당 측면에서 사용 가능한 공간과 같은 값을 가집니다.
    이를 활용하여 수평 중앙 정렬을 할 수 있습니다. 아래 코드를 살펴봅시다. -->
margin-left: auto;
margin-right: auto;
<!--좌우의 margin이 모두 auto로 적용 되었다면, 브라우저는 요소가 가질수 있는 가로 영역에서
    자신의 width를 제외한 나머지 여백에 크기에 대해 균등 분할 하여 적용합니다.
    이에 따라 요소는 수평 중앙 정렬이 됩니다. 상하의 경우 수직 중앙 정렬이 되지 않으며,
    기본적인 플로우를 벗어나는 상황에 대해서 적용이됩니다.
    이는 좀더 심화적인 개념이 필요하므로 기초에서는 수평 정렬에 대한 개념을 확실히 잡아두시길 바랍니다. -->

margin collapse(마진 병합)
<!--마진 병합은 인접한 두 개 이상의 수직 방향 박스의 마진이 하나(제일 큰값으로)로 합쳐지는 것을 의미합니다.
    마진 병합이 다음 세가지의 경우에 일어납니다.

1.두 요소가 상하로 인접한 경우: 위 요소의 하단 마진과 아래 요소의 상단 마진의 병합이 일어납니다.
2.부모 요소와 첫 번째 자식 요소 또는 마지막 자식 요소
    1.부모 요소의 상단 마진과 첫 번째 자식 요소의 상단 마진 병합이 일어납니다.
    2.부모 요소의 하단 마진과 마지막 자식 요소의 하단 마진 병합이 일어납니다.
3.내용이 없는 빈 요소의 경우: 해당 요소의 상단 마진과 하단 마진의 병합이 일어납니다.

마진 병합은 수직 방향으로만 이루어지며, 좌우에 대해서는 일어나지 않습니다.
마진 병합은 마진이 반드시 맞닿아야 발생하기 때문에 2,3번째의 경우 패딩 및 보더가 없어야 합니다.
마진 병합의 잘못된,올바른 예.PNG 참고-->


margin과 padding의 비교
         +      -     auto    단위
margin   o      o      o     px, % ...
padding  o      x      x     px, % ...
<!--음수값 사용 가능 여부!
    왜 margin은 음수 값 적용이 가능하고, padding은 적용되지 않을까요? 예를 들어 생각해보자면,
    padding은 뼈와 우리 피부 사이의 지방이라고 생각하고, margin은 사람과 사람 사이의 간격이라고 생각하면 쉽습니다.
    지방은 아무리 뺀다고 해서 피부가 뼈보다 밑으로 갈 수 없을 뿐만 아니라, 0 이하가 될 수 없으므로 양수만 된다고 생각하면 됩니다.
    그러나 사람과 사람 사이는 멀리 떨어질 수도 있지만, 서로 겹쳐서 서 있을 수도 있으므로 음수 값이 가능하다고 생각하면 됩니다.

    %값의 사용과 기준점
    css 속성을 사용하면서 어떤 값을 적용할 때 이 단위를 적용 할 수 있을까?
    라는 생각을 가지고 코딩하는 자세는 매우 중요합니다.
    margin과 padding은 px과 같은 고정적인 단위 외에도 %라는 상대적인 단위를 사용 할 수 있습니다.
    %는 요소의 크기를 기준으로 상대적인 값을 결정짓게 됩니다. 얼핏 생각하면,
    상하는 height 값에 대해 좌우는 width 값에 대해 크기가 계산될 거 같지만 그렇지 않습니다.
    %는 상하좌우의 방향에 관계없이 모두 요소(부모 요소(없으면 body값))의 width 값(해상도 가로 값 참고)을 기준으로 값이 결정 됩니다.-->
div {
   width: 100px;
   height: 200px;
   margin: 10%;
   padding: 10%;
}
<!--만약 위와 같은 코드의 경우에는 margin과 padding이 모두 20px 10px 20px 10px으로 적용되는 것이 아니라,
    10px 10px 10px 10px 값으로 적용됩니다. -->


content 영역의 가로 세로크기
<!--요소의 가로 크기를 지정하는 width 속성은 인라인 레벨 요소를 제외한 모든 요소에 적용됩니다.
    블록&인라인 강의에서 다룬 블록 레벨 요소와 인라인 레벨 요소의 특징을 되짚어보시기 바랍니다. -->
1.width 속성<!-- 기본 값 : auto (width값 지정안할때 부모 width 값으로 함)
< 속성 값 >
    auto : 브라우저에 의해 자동으로 계산하여 적용합니다. * 요소의 레벨 기본 특성에 따라 다르게 동작합니다.
    length : 고정값으로 지정합니다. (ex. px, em ....)
    percent : 부모 요소의 width에 상대적인 크기를 지정합니다.
    width는 content 영역의 너비를 제어할 때 사용하는데 이때 auto가 아닌 특정한 값을 지정하여 사용하면,
    그 크기는 box model 영역에서 margin 영역을 제외한 모든 영역에 대해 영향을 받습니다. (content, padding, border)
    예를 들어,
    <div class="box"> box </div>

    .box {
    width: 100px;
    padding: 20px;
    border: 10px solid black;
    }
    위와 같이 선언되어있다면 요소의 총 가로 크기는 160px가 됩니다.
    분명 width: 100px를 적용했는데 어떻게 160px가 된 걸까요?
    앞선 설명에서 언급한 바와 같이 width는 padding, border 영역에 대해서 영향을 받기 때문입니다.
div.box 160x79.PNG 참고
식으로 나타내면,
    100px content + ( 20px * 2(좌우)) padding + ( 10px * 2(좌우) ) border = 160px 가 된 것입니다.
     -->

%를 이용해서도 크기를 지정할 수 있습니다.
<div class="parent">
  <div class="child">
    child
  </div>
</div>

.parent {
  width: 300px;
  border: 20px solid red;
}
.child {
  width: 50%;
  padding: 20px;
  border: 10px solid black;
}
div.child 210x79.PNG 참고
<!--위와 같이 코드를 적용 했을 때 .child의 크기는 어떻게 적용될까요?
    정답은 210px 입니다.
    우선, padding (20px * 2) + border (10px * 2) = 60px 입니다.
    210px - 60px = 150px 이며,
    150px은 부모의 width가 300px이므로 300px의 50%인 150px이 width값으로 결정된 것입니다.
    결국 %값일 때에는 부모의 width값에 대해서 계산되어지는데,
    이때 부모의 width는 content 영역의 크기를 의미합니다.
    부모의 padding과 border까지 더해진 요소의 전체 크기가 아닌,
    *content 영역의 가로크기가 기준이라는 것을 기억하시면 됩니다.* -->


2.height 속성  <!--기본 값 : 0 (부모가 자식요소를 감싸고 있으면 자식들의 height값합에 결정된다.)-->
<!-- < 속성 값 >
    auto : 브라우저 자동으로 계산하여 적용합니다. * 기본적으로 컨텐츠 영역의 내용만큼 높이를 가집니다.
    length : 고정값으로 지정합니다. (ex. px, em ....)
    percent : 부모 요소의 height에 상대적인 크기를 지정합니다. * 단, 부모 요소가 명시적으로 height 값이 있어야 합니다.
    height는 content 영역의 높이를 제어할 때 사용하는데 이때 auto가 아닌 특정한 값을 지정하여 사용하면,
    width 속성과 마찬가지로 box model 영역에서 margin 영역을 제외한 모든 영역에 대해 영향을 받습니다.
예를 들어,
<div class="box"> box </div>

.box {
  width: 100px;
  height: 100px;
  padding: 10px;
  border: 15px solid black;
}
위와 같이 선언되어있다면 요소의 총 세로 크기는 150px이 됩니다.
앞선 설명에서 언급한 바와 같이 height도 padding, border 영역에 대해서 추가로 영향을 받기 때문입니다.

div.box 150x150.PNG 참고

식으로 나타내면,
100px content + ( 10px * 2) padding + ( 15px * 2 ) border = 150px 가 된 것입니다.
-->

%를 이용해서도 크기를 지정 할 수 있습니다.
<div class="parent">
  <div class="child">
    child
  </div>
</div>

.parent {
  width: 200px;
  border: 10px solid black;
}
.child {
  height: 50%;
  background: red;
}
위와 같이 코드를 적용 했을때,  .child 의 높이는 어떻게 적용 될까요?

div.child 200x19.PNG 참고

<!--실제로 확인해보면, height: auto일 때와 height: 50%일 때 차이가 없는 것을 확인할 수 있습니다.
    왜 두 값의 차이가 없는 걸까요?
    MDN에서 height 속성에 percent value에 대한 설명을 보면
    "Containing Block의 높이에 대한 백분율로 높이를 정의합니다."고 나와 있습니다.
    여기서 말하는 Containing Block(콘텐츠가 부모와 자식 사이에 차지 할 수 있는 영역)은 부모를 의미한다고 생각하시면 돼며
    부모요소에 heigh값을 따로 지정해 줘야 한다
    즉, 현재 위의 코드에서는 부모가 명시적인 높이 값을 가지고 있지 않기 때문에
    자식의 높이를 %값으로 지정해줘도 적용되지 않았던 것입니다.
    div.child 200x100.PNG 참고
    부모 코드에 height: 200px로 명시적으로 높이 값을 지정해주면,
    위와 같이 %값이 적용되는걸 볼 수 있습니다.-->

{box-sizing: content-box; }
<!-- box 사이즈를 어떤 기준으로 잡아서 전체 박스의 가로,세로를 설정하는 선언
    보통 content-box로 잡혀있으면 기본적으로 border-box로 설정해서 작업한다.
     -->

타이포그래피의 구조.PNG 참고
<!--폰트를 이해하기 위해서는 타이포그래피의 구조를 먼저 이해해야 합니다.
    모든 폰트는 em박스를 가지고 있고 위 그림(다이포그래피의 구조.png)과 같은 구조로 이루어져 있습니다.
    •em 폰트의 전체 높이를 의미합니다.
    •ex ( = x-height ) 해당 폰트의 영문 소문자 x의 높이를 의미합니다.
    •Baseline 소문자 x를 기준으로 하단의 라인을 의미합니다.
    •Descender 소문자에서 baseline 아래로 쳐지는 영역을 의미합니다.
    서체에 따라 descender의 길이가 다릅니다. ( g, j, p, q, y )
    •Ascender 소문자 x의 상단 라인 위로 넘어가는 영역을 의미합니다. ( b, d, h, l ) -->



line-height 속성
line-height: normal | number | length | initial | inherit ;
<!--기본 값 : normal
    line-height는 텍스트 라인의 높이를 의미하는 것으로 주로 행간을 제어할 때 사용됩니다. -->
그림1.PNG 참고
<!--행간을 제어할 때 사용하는 속성이라 해서 줄 간격으로 생각해 오해하기 쉬울 수가 있습니다.
    줄 바꿈이 되었을 때, 윗줄의 텍스트 하단과 아랫줄의 텍스트 상단까지의 간격이라고 생각할 수도 있지만,
    line-height로 제어되는 부분을 line-box라고도 하며
    이는 타이포그래피 구조에서 배웠던 [em 박스] + [상하단의 여백]까지를 의미합니다. 보통 단위는 em이며 보통 단위는 생략하다.

    < 속성 값 >

    normal : 기본값으로 브라우저의 기본 속성을 따릅니다.
    폰트에 따라 브라우저에 따라 다르지만 보통 1.2 정도로 할당되어 있습니다.
    number : font-size를 기준으로 설정한 숫자만큼 배율로 적용합니다.
    length : px, em 등 고정 수치로 할당할 수 있습니다.
    % : font-size를 기준으로 설정한 퍼센트만큼 배율로 적용합니다.

    주의할 점은, line-height의 값으로 number를 선언할 때와 %로 선언할 때의 차이입니다.
    두 값 모두 font-size를 기준으로 동작하기 때문에 1이나 100%를 같은 것이라고 오해할 수 있습니다.
    하지만 두 값은 큰 차이가 있습니다. 바로 line-height의 값이 자식 요소로 상속되었을 때의 계산 방식입니다.
    number 부모 요소의 숫자 값이 그대로 상속됩니다.
    즉, 자식 요소에서도 또 한 번 자식 요소의 font-size를 기준으로 계산된 값을 가집니다.
    % 부모 요소에서 %값이 그대로 상속되는 것이 아니고, %에 의해 이미 계산된 px값이 상속됩니다. -->

아래 코드를 예시로 보자면,
body { font-size: 20px; line-height: 2; }       /* line-height = 40px; */
body { font-size: 20px; line-height: 200%; }    /* line-height = 40px; */
<!--두 경우 모두 <body>에 똑같이 line-height: 40px이 적용됩니다.
    하지만 자식 요소로 <p>가 있다고 생각을 하면 얘기가 달라집니다. -->
body { font-size: 20px; line-height: 2; }    /* line-height = 40px; */
p { font-size: 10px; }                                  /* line-height = 20px; */


body { font-size: 20px; line-height: 200%; }    /* line-height = 40px; */
p { font-size: 10px; }                                          /* line-height = 40px; */
<!--이처럼 계산된 값이 아닌 숫자 값을 상속한다는 사실 때문에,
    숫자 값을 사용하면 부모 엘리먼트에서 계산된 값 대신 비율을 그대로 상속받을 수 있으므로,
    가능 하면 단위가 없는 값을 사용하는 것이 좋습니다. -->


font-size 속성
<!--기본 값 : medium
    글꼴의 크기를 지정하는 속성입니다. -->
font-size: keyword | length | initial | inherit ;
<!-- < 속성 값 >
      keyword : medium(기본 값),
      브라우저 마다 사이즈가 다르게 정의되어 있음, 부모 상속 없음
      (xx-small, x-small, small, large, x-large, xx-large, smaller, larger, medium)

      length : px, em 등 고정 수치로 지정합니다.
      % : 부모 요소의 font-size 기준의 퍼센트로 지정합니다.

      absolute size (keyword) : 기본 값인 medium에 대한 상대적인 크기로, 브라우저마다 사이즈가 다르게 정의되어있습니다.
      relative size (keyword) : 부모 요소의 font-size 크기에 대해 상대적입니다. smaller는 0.8배, larger는 1.2배입니다.
      length : px, em, rem 등의 단위를 이용하여 고정된 크기를 지정할 수 있습니다.
              - em :  부모 요소의 font-size에 em 값을 곱한 크기 - rem : 루트(html)의 font-size에 rem 값을 곱한 크기
      percent (%) :  부모 요소의 font-size를 기준으로 백분율 계산된 값을 지정할 수 있습니다.
      viewport units : vw, vh 단위로 뷰포트(브라우저 해상도)를 기준으로 하여, 유동적인 font-size를 지정할 수 있습니다.
                      vw는 뷰포트 width의 1%, vh는 뷰포트 height의 1% 값을 가집니다.
      inherit : 부모상속을 받을 수 있는 폰트 크기 속성
      initial : 태그가 갖고 있는 고유 폰트 크기 속성-->


font-weight 속성
<!--기본 값 : normal
    글꼴의 굵기를 지정하는 속성입니다. -->
font-weight: normal | bold | bolder | lighter | number | initial | inherit ;
<!--< 속성 값 >
    normal : 기본 값 (400)
    bold : 굵게 표현(700)
    bolder : 부모 요소 보다 두껍게 표현
    lighter : 부모 요소 보다 얇게 표현

    number : 100, 200, 300, 400, 500, 600, 700, 800, 900 (클수록 더 두껍게 표현)
    실무에서는 normal과  bold를 많이 사용하고, 부모 요소에 영향이 있는 bolder와 lighter는 사용을 될 수 있으면 지양하는 편입니다.
    물론 상속 관계에서 바뀌어야 하는 스펙이라면 당연히 유용하게 사용될 수 있지만, 그 외의 경우에는 사용에 있어 신중해야 합니다.
    font-weight는 normal, bold와 같은 키워드 외에 숫자로도 그 굵기를 표현할 수 있습니다.
    100~900까지 100단위로 값을 지정하여 사용할 수 있고 숫자가 커질수록 더욱 굵게 표현됩니다.
    기본적으로 400은 normal과 같고, 700은 bold와 같습니다
    Thin(100), Light(300), regular(400), Medium(500), bold(700), Extra Bold(800), black(900)

    그러나 수치를 이용한 font-weight는 폰트 자체에서 지원을 해야 표현할 수 있습니다.
    폰트에 따라 font-weight를 적용해도 굵기에 변화가 없을 수도 있으며,
    normal과 bold만 지원하는 폰트일 경우에는 100~500까지는 normal로, 600~900까지는 bold로 표현됩니다.
    폰트가 점차 다양해지면서 굵기 자체를 폰트 family-name으로 가지고 있는 경우도 있습니다.
    또한,  디바이스별로 조금 다르게 표현될 수도 있습니다.
    font-weight와 font-family, font-size는 서로 밀접하게 연관되어있습니다. -->


font-style속성
<!--기본 값 : normal
    글꼴의 스타일을 지정하는 속성입니다. -->
font-style: normal | italic | oblique | initial | inherit;
<!--< 속성 값 > 그림2.PNG 참고
    normal : font-family 내에 분류된 기본 값 (그림에서 첫번째)
    italic : italic 스타일로 표현합니다. (그림에서 두번째)
    oblique : oblique 스타일로 표현합니다. (그림에서 셋번째)
    oblique 텍스트의 기울기에 대한 각도를 추가로 지정할 수 있습니다.
    font-weight oblique <각도>;
    유효한 값은 -90 ~ 90도이며, 따로 각도를 지정하지 않으면 14도가 사용됩니다.
    양수 값은 글의 끝 부분 쪽으로 기울어지며, 음수값은 시작 부분 쪽으로 기울어집니다.
    그러나 아직 초안 단계로 CSS Fonts Module Level 4를 지원하는 브라우저에서만 사용 가능합니다.-->


font-variant 속성
<!--기본 값 : normal
    글꼴의 형태를 변형하는 속성으로 소문자를 작은 대문자로 변환할 수 있습니다. -->
font-variant: normal | small-caps | initial | inherit ;
<!--< 속성 값 >
    normal : 기본 값
    small-caps : 소문자를 작은 대문자로 변형합니다. -->



    font-family
    <!-- 속성 글꼴을 지정하는 속성입니다. -->
    font-family: family-name | generic-family ( | initial | inherit );
    <!--family-name: 사용할 폰트의 이름을 나타내며 ' , ' 로 구분하여 여러 개 선언 할 수 있습니다.
        먼저 선언된 순서대로 우선순위가 결정됩니다.  이름 중간에 공백이 있거나, 한글일 경우 홑따옴표로 묶어서 선언합니다.
        generic-family: family-name으로 지정된 글꼴을 사용할 수 없을 경우를 대비해,
        브라우저가 대체할 수 있는 폰트가 필요한 경우 선택할 수 있게 해줍니다.
        font-family 속성의 맨 마지막에 선언해야 하며, 키워드이기 때문에 따옴표 등의 인용부호로 묶지 않는 것이 원칙입니다.
        예를 들면 아래와 같이 선언하여 사용할 수 있습니다.  -->

    font-family: Helvetica, Dotum, '돋움', Apple SD Gothic Neo, sans-serif;
    <!-- 가장 먼저 Helvetica를 사용하고, 이를 사용할 수 없을 때 Dotum을 사용하는 방식으로 우선순위에 따라 차례대로 적용 됩니다.
          만약 "abc 가나다 123" 이라는 글자가 있다면, "abc"와 "123"은 Helvetica로 표현이 되고, "가나다"는 Dotum으로 표현이 됩니다.
          "가나다"가 Dotum으로 표현된 이유는 Helvetica는 한글을 지원하는 폰트가 아니기 때문입니다.
          그리고 예를 보면 돋움체를 영문으로 한번, 한글로 한번 선언 하였습니다. 왜 이렇게 선언 하였을까요?
          한글을 지원하지 않는 디바이스일 경우 해당 한글 폰트를 불러올 수 없으므로 영문명으로도 선언해 주어야합니다.
          마지막에는 반드시 generic-family를 선언 해주어야 합니다. 그 이유는 선언된 모든 서체를 사용할 수 있다는 보장이 없기 때문입니다.
          이때 generic-family를 선언해주면, 시스템 폰트 내에서 사용자가 의도한 스타일과 유사한 서체로 적용되기 때문입니다.
          또한, 자식 요소에서 font-family를 재선언하면 부모에 generic-family가 선언되어있어도 다시 선언해주어야 합니다.
          Generic-Family에는 대표적인 서체로 serif, sans-serif가 있습니다. serif는 삐침이라는 뜻이고,
          sans는 프랑스어로 '~이 없이'라는 의미가 있습니다. serif는 글자 획에 삐침이 있는 폰트로 대표적으로 명조체가 있으며,
          sans-serif는 획에 삐침이 없는 폰트로 대표적으로 돋움체가 있습니다. -->

웹포트 적용방법
1. 갖다 쓴다.
<!--html문서 head태그안에 다음과 같이 쓴다
    <link href="폰트 다운로드 주소" rel="파일명관계"
    css파일에 가서 폰트를 적용할 태그에 다음과 같이 작성하면 끝
    body {
        font-family: webNanumGothic;

    }-->

2. 직접 제공한다.
@font-face
<!--기본 값 : 없음
    웹에 있는 글꼴을 사용자의 로컬 환경(컴퓨터)으로 다운로드하여 적용하는 속성입니다.
    여러가지 경로를 설정할 수 있다-->
@font-face {
    font-properties
}
<!--< 속성 값 >
    font-family(필수) : 글꼴의 이름을 지정
    src(필수) : 다운로드 받을 글꼴의 경로(URL)(.브라우저 지원하는 확장자 입력),
                사용자 컴퓨터에 설치된 폰트명을 local("font name")형식으로 지정하는 속성이다.
    font-style(옵션) : 글꼴의 스타일 지정, 기본 값은 normal
    font-weight(옵션) : 글꼴의 굵기 지정, 기본 값은 normal

  Font Type(폰트 파일 유형)
  EOT(Embedded Open Type) :  IE에서만 통용됩니다. 일반 폰트 파일을 EOT로 변환하려면 특별한 도구가 필요합니다.

  TrueType과 OpenType : 컴퓨터의 Fonts 폴더를 열어보면 .ttf(TrueType format)와 .otf(OpenType format) 서체 파일들이 보일 것입니다.
  대개 컴퓨터 서체 파일로 널리 사용되는 파일 형식입니다. 웹 페이지 뿐만 아니라, 워드 프로세싱이나 전자출판에도 사용할 수 있습니다.
  이런 유형의 서체 파일은 대부분의 브라우저가 지원하며 IE9를 포함한 최신 버전의 IE, 크롬, 파이어폭스, 사파리, 오페라, iOS 사파리(4.2+),
  그리고 블랙베리 브라우저 등이 여기에 해당합니다.

  WOFF(Web Open Font Format) : 이 파일은 웹을 주된 대상으로 설계된 파일 형식입니다.
  WOFF 서체는 기본적으로 TrueType이나 OpenType 서체를 압축한 것이기 때문에 일반적으로 파일 크기가 작아서,
  다른 서체보다 신속히 다운로드됩니다. WOFF 파일은 다양한 브라우저 제조사의 지지도 받고 있어서
  IE9 를 비롯한 모던 브라우저와 iOS 사파리(5+)에서 지원하고 있습니다.
  하지만 안드로이드 진영에서 이 파일을 지원하지 않고 있어서 안드로이드 기기나 IE8 사용자는 서체를 다운받거나 표시할 수 없습니다.

  SVG(Scalable Vector Graphic) : 이 파일은 사실 서체 파일은 아닙니다.
  SVG는 사실 벡터 그래픽(확대해도 품질이 유지되는 이미지를 만드는 기술)을 위한 파일입니다.
  SVG 폰트를 지원하는 브라우저는 매우 제한적으로 IE, FF는 지원하지 않는다.
  SVG의 또 한가지 문제는 파일 크기가 TrueType의 거의 두 배, WOFF 파일의 거의 세 배에 달한다는 것입니다.
  SVG를 사용해 얻을 수 있는 진정한 이득은, iOS 사파라 4.1 이전 버전에서 인식하는 유일한 웹 폰트 타입이라는 것입니다.


  출처: https://webclub.tistory.com/261 [Web Club]-->


사용 예시는 다음과 같습니다.
font.css 파일을 만들어 아래와 같이 선언하고
@font-face {
  font-family: 'MyWebFont';<!--폰트 네임과 같지 않아도 됨 임의로 지정가능
  대신 적용해야 할 태그에 임의로 지정한 네임으로 해야함-->
  font-style: italic;
  font-weight: bold;
  src: url('webfont.eot'); /* IE9 Compat Modes */
  src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
       url('webfont.woff2') format('woff2'), /* Super Modern Browsers */
       url('webfont.woff') format('woff'), /* Pretty Modern Browsers */
       url('webfont.ttf')  format('truetype'), /* Safari, Android, iOS */
       url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */

}
<!--@font-face {
    font-family: webNanumGothic; /* 사용자 지정 웹 폰트명 */
    src : url(NanumGothic.eot); (format()=지원가능한 파일만 다운로드 받을 수 있음)/* 적용 될 웹 폰트의 경로 */
          local(※)/* 로컬에 이미 설치된 경로*/※기호는 사이트를 방문한 사용자 컴퓨터에 존재하지
          않는 글꼴을 임의로 지정하기 위한 것으로, 사용자가 접속하면 당연히 파일이 없기때문에 URL에 명시된
          경로로 파일을 다운로드 받아서 보여주게 됨.
    font-weight: bold; /* 필요에 따라 지정 */
    font-style: italic; /* 필요에 따라 지정 */
                  .
                  .
                  . 등등-->

파일명과 지원하는 확장자명과 함께 수정하고 html 문서에 적용합니다.
이때 폰트 굵기를 여러가지로 적용할 거면 font-face를 해당 선언할 굵기를 수만큼 선언해줘야 함
적용방법은 font.css를 링크태그를 사용하여 스타일 css 파일이랑 똑같이 적용하거나
스타일 css파일안에 다음과 같이 적용하면 됩니다.
@import url("폰트.css파일 경로");

}
그리고 css파일안에 body 태그에 아래와 같이 스타일을 추가하면 끝.
body {
    font-family: webNanumGothic;

}
<!-- 웹폰트는 선언 시 웹폰트에 따라 굵기나 스타일 간격 등을 같이 지정해서 사용할 수 있습니다 -->



font 관련 속성
<!--기본 값 : 각 속성들의 기본 값
    font-style, font-variant, font-weight, font-size/line-height, font-family
    속성들을 한 번에 선언할 수 있는 축약형 속성입니다.-->
font: font-style font-variant font-weight font-size/line-height font-family | initial | inherit;
<!--< 속성 값 >
    font-style : font-style 지정, 기본 값은 normal
    font-variant : font-variant 지정, 기본 값은 normal
    font-weight : font-weight 지정, 기본 값은 normal
    font-size/line-height : font-size/line-height 지정, 기본 값은 normal
    font-family : font-family 지정 -->

/* style | size | family */
font: oblique 2em "돋움", dotum, sans-serif;

/* style | variant | weight | size/line-height | family */
font: oblique small-caps bold 16px/1.5 '돋움';

/* The font used in system dialogs */
font: message-box;
font: icon;
<!--축약형을 선언할 때는 아래 사항들을 유의해야 합니다.
    1. font-size와 font-family는 반드시 선언해야 하는 필수 속성입니다.
    2. 빠진 속성이 있다면 기본 값으로 지정됩니다.
    3. 각 속성의 선언 순서를 지켜야 합니다. -->


vertical(수직)-align 속성
<!--기본 값 : baseline
    요소의 수직 정렬을 지정하는 속성입니다.
    인라인 레벨에만 선언 할 수 있고,
    테이블 셀 상자의 수직 정렬을 지정할 때 사용함-->
vertical-align: keyword | length | percent | initial | inherit ;
<!--< 속성 값 >
    length : 요소를 지정한 길이만큼 올리거나 내림. 음수 허용
    %, em : 요소를 line-height를 기준으로 올리거나 내림. 음수 허용
    keyword : baseline(기본 값), sub, super, top, text-top, middle, bottom, text-bottom -->

vertical-align은 기본 값이 baseline입니다.
<!--이전에 타이포그래피 구조 강의에서 설명했듯이 baseline은 소문자 ex를 기준으로 하단 라인을 의미합니다.
    keyword
    sub : 부모 아래 첨자 기준으로 정렬
    super : 부모 위 첨자 기준으로 정렬
    text-top : 부모 텍스트의 맨 위(Ascender 제외)
    text-bottom : 부모의 텍스트의 맨 아래(Descender 제외)
    middle : 부모의 ex 기준 중앙에 위치
    top : 부모의 맨 위 위치
    bottom : 부모의 맨 아래 위치
    length px값 사용 시 baseline을 기준으로 이동하며, 음수 값도 사용 가능합니다.
    percent ( % ) line-height를 기준으로 내에서 이동하며 음수 값 사용 가능합니다. -->


text-align 속성
 <!--기본 값 : left (Right to Left 언어일 경우는 right)
      텍스트의 정렬을 지정하는 속성입니다.  -->
text-align: left | right | center | justify | initial | inherit ;
<!--기본 값은 left이지만 경우에 따라 다릅니다.
    문서의 방향이 LTR(Left To Right) 왼쪽에서 오른쪽 방향인 언어일 경우 left가 기본값이고,
    RTL(Right To Left) 로 오른쪽에서 왼쪽으로 읽힐 경우 right가 기본값이 됩니다.
< 속성 값 >
    left : 텍스트를 왼쪽으로 정렬
    right : 텍스트를 오른쪽으로 정렬
    center : 텍스트를 중앙으로 정렬
    justify : 텍스트를 라인 양쪽 끝으로 붙여서 정렬. (마지막 라인은 정렬 하지 않음) -->

text-align과 display의 관계
<!-- -text-align은 inline-level에 적용
     -text-align은 block-level에 적용할 수 없음 즉 박스를 정렬 할 수 없음
     그렇다면 block 요소를 가운데 정렬 하고자 한다면 어떻게 해야 할까요?
     박스모델 챕터에서 다룬 margin의 auto 값을 이용해서 하시면 됩니다.
     가운데 정렬 인라인 요소 : text-align (center) 블럭 요소 :  margin (auto)
     요소의 레벨에 따라 정렬하는 방식의 차이를 바로 알고 있으시기 바랍니다. -->


text-indent 속성
<!--기본 값 : 0
    텍스트의 들여쓰기를 지정하는 속성입니다. -->
text-indent: length | initial | inherit;
<!--< 속성 값 >
    length : px, em 등 고정 수치로 지정. 음수 허용
    % : 부모 요소의 width를 기준으로 퍼센트로 지정
        (실제 해본결과 해당요소에 컨텐츠 가로값을 기준으로 나옴)-->


text-transform
<!--알파벳문자에만 쓸 수 있는 속성 기본값 none
    속성값
    capitalize: 단어 앞에만 대문자 설정
    uppercase: 모두 문자가 대문자 설정
    lowercase: 모두 문자가 소문자 설정-->


text-decoration(장식) 속성
<!--기본 값 :  none   currentColor   solid
    텍스트의 장식을 지정하는 속성입니다. 아래 속성들의 단축 속성으로,
    기본 값은 차례대로 아래 3가지 속성의 값입니다.(선언순서 상관X)-->
text-decoration: text-decoration-line text-decoration-color text-decoration-style | initial | inherit;

text-decoration-line
<!--텍스트 줄의 위치를 지정하는 속성입니다.(상속x)
    속성 끼리 중복가능
    기본 값 : none
< 속성 값 >
    none : 텍스트 꾸밈을 생성하지 않음 ( 기본값 )
    underline : 밑줄로 꾸밈을 설정
    overline : 윗줄로 꾸밈을 설정
    line-through : 중간을 지나는 줄로 꾸밈을 설정 -->

text-decoration-color
<!--텍스트 줄의 색상을 지정하는 속성입니다. (상속x)
    기본 값 : currentColor
    색상 값을 사용하여 원하는 색상을 지정할 수 있습니다. -->

text-decoration-style
<!--꾸밈에 사용되는 선의 스타일을 지정하는 속성입니다.(상속x)
    기본 값 : solid
< 속성 값 >
    solid : 한줄 스타일 ( 기본 값 )
    double : 이중선 스타일
    dotted : 점선 스타일
    dashed : 파선 스타일
    wavy :물결 스타일 -->


white-space 속성
<!--기본 값 : normal
    요소 안에 공백을 어떻게 처리할지 지정하는 속성입니다. -->
white-space: normal | nowrap | pre | pre-line | pre-wrap | initial | inherit;
<!--< 속성 값 >
    normal : 공백과 개행을 무시하고, 필요한 경우에 자동 줄바꿈 발생. 기본 값
    nowrap : 공백과 개행을 무시하고, 자동 줄바꿈이 일어나지 않음.
    pre : 공백과 개행을 표현하고, 자동 줄바꿈이 일어나지 않음.
    pre-line : 공백은 무시하고, 개행만 표현. 필요한 경우에 자동 줄바꿈 발생.
    pre-wrap : 개행은 무시하고, 공백만 표현. 필요한 경우 자동 줄바꿈 발생. -->

letter-spacing 속성
<!--기본 값 : normal
    자간을 지정하는 속성입니다. 단위는 주로 em을 사용 -->
letter-spacing: normal | length | initial | inherit;
<!--< 속성 값 >
    normal : 기본 값
    length : 길이만큼 자간(글자 간의 사이)을 지정. 음수 허용 -->

word-spacing 속성
<!--기본 값 : normal
    단어 사이의 간격을 지정하는 속성입니다. -->
word-spacing: normal|length|initial|inherit;
<!--< 속성 값 >
    normal : 기본 값
    length : 길이만큼 단어 사이의 간격을 지정. 음수 허용 -->

word-break 속성
<!--기본 값 : normal
    단어가 라인 끝에 나올 경우 어떻게 처리할지(중단점) 지정하는 속성입니다. -->
word-break: normal | break-all | keep-all | initial | inherit;
<!--< 속성 값 >
    normal : 기본 값. (non-CJK)중단점은 공백이나 하이픈(-)(CJK는 음절),(CJK=중국어,일본어,한국어)
    break-all :중단점은 음절. 모든 글자가 요소를 벗어나지 않고 개행
    keep-all : 중단점은 공백이나 하이픈(-)(CJK는 그 외 기호도 포함) -->

word-wrap 속성
<!--기본 값 : normal
    요소를 벗어난 단어의 줄바꿈을 지정하는 속성입니다. -->
word-wrap: normal|break-word|initial|inherit;
<!--< 속성 값 >
    normal : 기본 값. 중단점에서 개행 (non-CJK)중단점은 공백이나 하이픈(-)(CJK는 음절),(CJK=중국어,일본어,한국어)
    break-word : 모든 글자가 요소를 벗어나지 않고 강제로 개행 -->


display 속성
<!--기본 값 : - (요소마다 다름)
    요소의 렌더링 박스 유형을 결정하는 속성입니다. -->
display: value;
<!--< 속성 값 >
    none : 요소가 렌더링 되지 않음
    inline : inline level 요소처럼 렌더링
    block : block level 요소처럼 렌더링
    inline-block : inline level 요소처럼 렌더링(배치)되지만 block level의 성질을 가짐
    flex: 불록이랑 비슷한데 불록을 할 수 없는, 즉 요소를 쉽게 정렬 할 수 있는 속성값이다.
    inline-flex: inline-block 처럼 비슷한데 인불이할 수 없는것을 함

    * height 나 width 등과 같은 박스모델 속성을 적용할 수 있다

    그외에 list-item,  table, table-cell 등 다양한 속성 값 존재
    inline level 요소 사이의 공백과 개행 처리 : inline 요소의 경우 공백과 개행에 대해서 하나의 여백으로 받아들입니다.
    따라서 inline와 inline-block의 경우 태그 사이의 공백이나 개행이 있을 경우 약 4px의 여백을 가지게 됩니다.-->


display와 box model의 관계
<!--
display    width   height   margin   padding   border
block        ㅇ      ㅇ        ㅇ       ㅇ        ㅇ
inline       X       X       좌/우      ㅇ(설명)   ㅇ(설명)
inline-block ㅇ      ㅇ        ㅇ       ㅇ        ㅇ

inline 요소의 padding/border 속성이 좌/우 만 적용 된다고 표시한 이유 추가 설명
실제로 inline 요소의 padding/border는 좌/우뿐만 아니라 상/하에도 적용이 됩니다.
그림3.PNG 참고
parent 는 <div>, child 는 <span>
하지만 상/하 padding/border는 line-box에는 영향을 주지 못하기 때문에 위와 같이 부모 요소의 박스에 반영되지 않습니다.
그림4.PNG 참고
parent 는 <div>, child 는 <span>
또한 인접한 다른 line-box 에도 반영되지않습니다. 즉 콘텐츠가 겹칠 수 있기 때문에 실무에서는 잘 사용하지 않습니다.
line-box에 대해 궁금하거나 기억이 나지 않으신다면 Chapter06에 line-height 강의를 참고하시면 됩니다.-->


.flexbox{
  display:flex/inline-flex;
  flex-direction: row;
  flex-wrap:nowrap;
  justify-content:flex-start;
  (align-items:flex-strart;)
  (align-content:flex-strart;)
}
<!-- 위 속성은 정렬을 하고자 하는 요소를 지니고 있는 부모에다가 선언해줘야 한다.
    flex: 박스 타입이며 불록(수직쌓임)이랑 비슷한데 불록을 할 수 없는 요소를 쉽게 정렬 할 수 있게 해주는 속성값이다.
    inline-flex: inline-block 처럼 비슷한데 인불이할 수 없는것을 함(수평쌓임)
    
    flex-direction: 어느 방향 정렬을 할 건지 설정
    =flex, line-flex차이는 부모요소간에 수직과 수평의 차이이다.
    값으로는 row(가로,기본값), row-reverse(오른쪽에서 왼쪽으로 가로), colum(세로), column-reverse(아래에서 위로 세로)
    flex-wrap:한 줄 안에 모두 정렬을 할 것인지, 여러줄로 정렬 할 것인지 결정
    값으로 nowrap(부모가로 값에 맞게 자식요소들의 크기를 줄여 한 줄에 배치, 기본값)
    wrap(부모가로 값에 맞게 한줄에 자식이오고 다음줄에 부모가로값에 초과한 자식이 옴 총 두줄이 생성), wrap-reverse(서로 두 줄자리를 바꾸는 속성값)
    =flex-flow: flex-direction, flex-wrap속들을 간략히 한 속성
    값으로는 nowrap, row wrap, column rwap.

    flex를 사용하면 보이지 않는 두개의 축(Axis)이 생기는데 direction값에 따라 축에 방향이 달라짐
    축에는 main axis, cross axix 두개 축이 생김 main은 direction값에 방향의 따라 생김

    cross은 메인과 정확히 수직을 이루는 방향으로 생김
    main 축기준으로 정렬 하고 싶은면 justify-content속성을 쓰고
    cross 축기준으로 정렬하고 싶으면 align-items, align-content속성을 쓰면됨
    = align-content(wrap값을 쓰면 두개 줄에 각각 축(max,cross) 생기는데 이것들을 하나의 축(max,cross)으로 만드는 속성)
     
    jsutify-content 속성값으로 flex-start(기본값), flex-end, cneter, space-between(요소들 사이에 동일한 간격을 둠), space-ground(요소들 주위에 동일한 간격을 둠)
     
    align-itmes 속성값은 flex-start(기본값), flex-end, cneter, baseline(items에 폰트베이스라인의 시작 위치에 정렬합니다.), stretch(items을 축전체영역에 맞도록 늘립니다.)
    
    align-self: align-items 값을 무시하고 flex요소를 세로선 상에서 정렬함
    속성값은 align-itmes와 동일.

    order: flex된 해당 요소하나를 지정해서 순서를 지정합니다. 값은 -1(왼쪽),0(기본값 해당자리),1(오른쪽)-->

    
display:table
<!--table : <table> 요소처럼 표현합니다. width:100% 선언
    table-caption : <caption> 요소처럼 표현합니다.
    table-column-group : <colgroup> 요소처럼 표현합니다.
    table-header-group : <thead> 요소처럼 표현합니다.
    table-footer-group : <tfoot> 요소처럼 표현합니다.
    table-row-group : <tbody> 요소처럼 표현합니다.
    table-cell : <td> 요소처럼 표현합니다.
    table-column : <col> 요소처럼 표현합니다.
    table-row : <tr> 요소처럼 표현합니다.
    table-layout: fiexed =테이블의 크기를 글자요소로 커지 않게 해주는 속성-->


opacity속성
<!--이 속성은 투명도 설정하는 속성이다.
    값은 단위없이 숫자(0,1,1.5등)만 입력한다 소수점도 가능-->


 visibility 속성
<!--기본 값 : visible
    요소의 화면 표시 여부를 지정하는 속성입니다. -->
visibility: visible | hidden | collapse | initial | inherit;
<!--< 속성 값 >
    visible : 화면에 표시
    hidden : 화면에 표시되지 않음(공간은 차지함)
    collapse : 셀 간의 경계를 무시하고 숨김(테이블 관련 요소에만 적용 가능) -->
visibility: visible;  /* 보임 기본값 */
visibility: hidden;  /* 숨김, 자신의 박스 영역은 유지(margin까지 모두 포함) */
visibility: collapse; /* 셀간의 경계를 무시하고 숨김(박스영역 없음, 테이블의 행과 열 요소에만 지정 가능, 그 외 요소 지정은 hidden과 같음) */

display: none과 차이점
<!--display: none: 요소가 렌더링 되지 않음(DOM에 존재하지 않음)
    visibility: hidden: 요소가 보이지는 않지만 렌더링 되며 화면에 공간을 가지고 있음(DOM에 존재함) -->


float 속성
<!--기본 값 : none
    요소를 float(요소를 보통의 흐름에서 벗어나게 함) 시킬지 지정하는 속성입니다. -->
float: none | left | right | initial | inherit;
< 속성 값 >
<!--none : float 시키지 않음(기본값)
    left 좌측으로 float 시킴
    right : 우측으로 float 시킴 -->

특징
<!--요소를 보통의 흐름에서 벗어나 띄어지게 함
    주변 텍스트나 인라인 요소가 주위를 감싸는 특징이 있음
    float인 요소에 width값을 주지않으면 컨텐츠 값의 사이즈로 잡하며
    옆에 길막이 안되고 다른 요소들이 온다.-->

<!-- 대부분 요소의 display 값을 block으로 변경함 (display 값 변경 예외: inline-table, flex 등) -->

clear 속성
<!--기본 값 : none
    block-level 요소만 적용 가능
    요소를 floating 된 요소의 영향에서 벗어나게 하는 속성입니다.
    즉 floating 된 요소의 자리을 차지 하지 않음.-->
clear: none | left | right | both | initial | inherit;
<!--< 속성 값 >
    none : 양쪽으로 floating 요소를 허용(기본값)
    left : 왼쪽으로 floating 요소를 허용하지 않음
    right : 오른쪽으로 floating 요소를 허용하지 않음
    both : 양쪽으로 floating 요소를 허용하지 않음
  =clear속성은 보통 floating된요소를 포함한 부모값에 가상요소(::after)를 적용해서 쓴다.
    그 이유는 부모가 floating된 요소를 포함하기 위해서 이다.
    그 과정은 가상요소를 설정하고 clear속성을 주면 가상요소는 가상박스가 생성되고
    가상박스는 floating된요소의 다음 위치에 지정돼서 부모가 floating요소를 포함 할 수 있게 된다.-->


offset(top/left/bottom/right)
top|bottom|left|right: auto|length|initial|inherit;
    <!--top: 50%;
        left: 10px;
        bottom: -10px;
        right: auto; -->
    offset의 %단위 사용
    <!--이전에 padding과 margin에서 % 값을 적용할 때, 상하좌우 방향에 관계없이  가로 사이즈를 기준으로 %값을 계산된다고 배웠습니다.
        그러나 offset은 top, bottom (상하) 는 기준이 되는 요소의 height 값 left, right (좌우) 는 width값에 대하여 계산되어집니다. -->

position 속성
<!--기본 값 : static
    요소의 위치를 정하는 방법을 지정하는 속성입니다. -->
position: static | absolute | fixed | relative | sticky | initial | inherit;
< 속성 값 >
<!--static : Normal-flow 에 따라 배치되며 offset 값이 적용되지 않는다. (기본값)

    absolute :부모 요소의 위치(padding 영역 안에서)를 기준으로 offset 에 따라 배치된다.
              부모가 position 값(static 제외)을 가지면 offset 값의 시작점이 된다.
              *부모의 position 값이 static 인 경우 조상의 position 값이 static이
              아닐 때까지 거슬러 올라가 기준으로 삼습니다. 최종 body가 기준이 됨
              Normal-flow의 흐름에서 벗어난다.

    fixed : 뷰포트(브라우저의 창)를 기준으로 offset 에 따라 배치된다.
            즉, 화면 스크롤에 관계없이 항상 화면의 정해진 위치에정보가 나타난다.
            부모의 위치에 영향을 받지 않는다.

    relative : 자신이 원래 있어야 할 위치를 기준으로 offset 에 따 라 배치된다.
              부모의 position 속성에 영향을 받지 않는다.
              Normal -flow의 흐름에 따른다.
              주변 요소에 영향을 주지 않으면서 offset 값으로 이동한다 -->


Normal-flow란?
 <!--일반적인 상황에서 각의 요소들의 성질에 따라 배치 되는 순서(흐름)를 뜻합니다.
    예를 들면, block 레벨 요소들은 상하로 배치되고, inline 레벨 요소들은 좌우로 배치되는 것을 말합니다. -->


z-index 속성
<!--기본 값 : auto
    요소가 겹치는 순서(쌓임 순서 또는 stack order)를 지정하는 속성입니다. -->
z-index: auto | number | initial | inherit;
< 속성 값 >
<!--auto : 쌓임 순서를 부모와 동일하게 설정(기본값)
    number : 해당 수치로 쌓임 순서를 설정(음수 허용) -->

z-index: 1;
<!--position 값이 static이 아닌 경우 지정가능
    순서 값이 없을 경우 생성순서(코드상 순서)에 따라 쌓임
    부모가 z-index 값이 있을 경우 부모 안에서만 의미있음
    (=다른 부모값이 작고 해당 부모자식이 커도 해당부모값이 작으면 다른 부모가 위에 겹친다)
    큰 값이 가장 위쪽(음수 사용 가능) -->


cursor태그
<!-- 특정 버튼을 누를 수 있게 겉으로 표현해주는 태그이다.
속성값:pointer-->


sr-only 클래스
<!--부스트트랩 관련 cdn을 연결해 놓으면 동작하지만, 별도로 css에 마크업을 해두는 것을 추천
인터넷이 안되는 경우를 대비하거나 해당 cdn 링크 주소가 깨지는 경우 동작을 하지 않기 때문
sr-only 클래스 속성은 아래와 같다-->
.sr-only{
  position:absolute;=(위치를 지정함.
  위로 붕 뜬 상태가 되어 뒤에 오는 요쇼들의 자리를 차지하지 않게 됨.)
  z-index:-100;
  width: 1px;
  height: 1px;
  overflow: hidden;=(현재 크기 이상의 영역은 모두 감춤)
  opacity: 0
}


미디어 쿼리
<!--미디어쿼리 소개
    미디어퀴리(Media Queries)는 각 미디어 매체에 따라 다른 스타일(css style)을 적용할 수 있게 만드는 것입니다.
    미디어 매체는 모니터와 같은 스크린 매체, 프린트, 스크린 리더기와 같은 것들을 이야기 합니다.
    미디어쿼리는 동일한 웹 페이지를 다양한 환경의 사용자들에게 최적화된 경험을 제공할 수 있게 해줍니다.
    미디어쿼리는 CSS2의 미디어 타입(Media Types)을 확장해서 만들어졌습니다.
    미디어타입은 이론적으로는 훌륭했지만, 결과적으로 제대로 활용되지 못했습니다.
    이유는 당시에는 미디어 타입을 제대로 지원하는 기기가 없었기 때문입니다.
    미디어 쿼리가 등장하기 이전에는 제대로 된 반응형 웹 사이트를 제작할 수는 없었습니다.
    하지만 당시에는 사용자들의 환경이 아주 제한적이었기 때문에 제작자 입장에서는
    대중적인 미디어 범위에서만 잘 보이도록 사이트를 제작하면 반응형이 아니더라도 충분했습니다.
    하지만 웹이 급격이 발전하면서 대응해야 하는 미디어의 폭이 상당히 늘어났습니다.
    이런 필요성에 따라 W3C는 CSS2의 미디어 타입을 확장하여, CSS3 미디어쿼리를 발표합니다.
    이 미디어 쿼리로 인해 웹 사이트를 제작함에 있어 이전의 정적인 고정 레이아웃 웹 사이트에서
    동적으로 반응하는 반응형 웹 사이트로  패러다임이 새롭게 변화하였습니다. -->

@media(at media)
<!--미디어 쿼리는 CSS2 Media Types을 확장했기 때문에 선언 방법은 동일합니다. -->
@media mediaqueries { /* style rules  */ }
<!--@media 로 시작하며, 이 키워드는 이제부터 미디어 쿼리를 시작한다 라는 뜻입니다.
    그 뒤에 미디어 쿼리 구문(위 코드의 mediaqueries) 이 나오고 이어서
    중괄호( { } )를 이용해서 스타일 규칙이 들어갑니다.
    미디어 쿼리 구문은 논리적으로 평가되며 참이면 뒤에 나오는 스타일 규칙이 적용되고, 거짓이면 무시됩니다.
    미디어 쿼리 구문은 미디어 타입(Media Types)과 미디어 특성(Media Features)으로 이루어져 있습니다. -->

미디어 타입(media types)
all, braille, embossed, handheld, print, projection, screen, speech, tty, tv
<!--우리가 알아야 할 타입은 all, print, screen 정도입니다.
    그 중에서도 screen이 거의 대부분입니다.
    화면을 출력하는 디스플레이가 있는 미디어들은 전부 screen에 속하기 때문에 현실적으로 고려해야하는 미디어들은
    전부 여기에 해당이 됩니다.
    print 타입도 간혹 사용이 됩니다. 실습할 때 다룹니다.
    all 타입은 모든 미디어에 적용되는 타입입니다. 미디어를 구분하는 용도가 아니기 때문에 유용하게 사용되지는 않습니다. -->

미디어 특성(media features)
width, height, device-width, device-height, orientation, aspect-ratio,
device-aspect-ratio, color, color-index, monochrome, resolution, scan, grid
<!--미디어 특성 역시 우리가 알아야 할 특성은 width와 orientation 정도입니다.
    width는 뷰포트의 너비, 즉 브라우저 창의 너비를 말합니다.(스크린의 크기 x)
    orientation은 미디어가 세로모드인지 가로모드인지를 구분합니다.
    미디어 쿼리에서는 이 구분을 width와 height 특성의 값을 비교해서 height가 width보다 같거나 크면 세로모드
    반대인 경우에는 가로모드라고 해석합니다. 세로모드에서는 portrait, 가로모드에서는 landscape 키워드와 매칭이 됩니다. -->

미디어 쿼리 level 4
<!--우리 수업의 미디어 타입과 미디어 특성은 CSS3 미디어 쿼리 표준 명세를 기준으로 작성되었습니다.
    현재, 미디어 쿼리 level 4가 CR(유력 후보안) 단계입니다.
    해당 문서에서 미디어 타입 대부분과 미디어 특성 중 일부 속성이 폐기 예정입니다.
    아래 참고 URL을 봐주세요.
    Media Queries Level 4
    https://www.w3.org

    Media Queries Level 4
    https://www.w3.org-->


미디어 쿼리 Syntax
media_query_list
: S* [media_query [ ',' S* media_query ]* ]?
;
media_query
: [ONLY | NOT]? S* media_type S* [ AND S* expression ]*
| expression [ AND S* expression ]*
;
expression
: '(' S* media_feature S* [ ':' S* expr ]? ')' S*
;
<!--위 코드는 CSS3 미디어 쿼리 표준 명세에 나와 있는 Syntax 부분입니다. 우리가 알아야 할 부분만 적어놓았습니다.
    참고로 Syntax는 전부 이해할 필요는 없지만 일부 기호는 알아두면 좋습니다.

    S* : 공백에 관련되 표시 없다고 보면됨
    [ a ] : a가 나올 수도 있고 나오지 않을 수도 있습니다.
    a | b : a 또는 b 둘 중에 하나를 선택합니다.
    "|"는 파이프 라인 기호로 키보드의 역슬래시(\) 키를 Shift 키를 누른 채로 누르면 나옵니다.
    a? :  a가 0번 나오거나 1번만 나올 수 있음
    a* : a가 0번 나오거나 그 이상 계속 나올 수 있음
    media_type : all, screen, print 등 명세에 정의된 미디어 타입
    media_feature : width, orientation 등 명세에 정의된 미디어 특성
    위 Syntax를 요약하면

    media_query_list
        : 여러개의 미디어 쿼리로 이루어진 리스트로 작성 가능하며, 쉼표를 이용해서 구분합니다.

    media_query
        : A 형태 -미디어 타입에 and 키워드를 이용해서 미디어 표현식을 붙일 수 있습니다.
                  미디어 타잎 앞에는 only 또는 not 키워드가 올 수 있습니다.
                  미디어 표현식은 생략 가능하기 때문에 미디어 타입 단독으로 사용될 수 있습니다.
        : B 형태 -미디어 타입 없이 미디어 표현식이 바로 나올 수 있습니다.(미디어 타입이 명시되지 않으면 all로 간주합니다.)
                  미디어 표현식은 and 키워드를 이용해서 계속해서 나올 수 있습니다.

    expression
        : 미디어 표현식은 괄호로 감싸야 하며, 특성 이름과 해당하는 값으로 이루어집니다. 이름과 값은 : 기호로 연결합니다.
          또, 값이 없이 특성 이름만으로도 작성할 수 있다. -->

min-/max- 접두사
<!--미디어 특성은 이름 앞에 min- 또는 max- 접두사를 붙일 수 있습니다.
    실제로 반응형 사이트를 제작할 때는 보통 접두사를 붙여서 사용합니다.
    접두사를 붙이지 않고 사용하는 경우 대부분 효율적이지 못하기 때문입니다.
    예를 들어 대부분의 반응형 사이트는 width 특성을 이용하는데, 접두사 없이 width: 00px 이라고 하게 선언하면
    정확히 뷰포트의 크기가 00px 에서만 적용되기 때문에, 다양한 기기들을 대응하기 힘듭니다.
    그래서 접두사를 사용하여 범위를 지정하게 되면 훨씬 간결하게 반응형 사이트를 제작할 수 있습니다.

    예제 코드
    위에서 정의한 Syntax 따라 유효한 미디어 쿼리 예제 코드를 살펴보고 어떻게 해석이 되는지 같이 봅니다.

    @media screen { ... }
        : 미디어 타입이 screen이면 적용됩니다.

    @media screen and (min-width: 768px) { ... }
        : 미디어 타입이 screen이고 width가 768px 이상이면 적용됩니다. 두 개 중 하나라도 만족하지 않으면 거짓이 됩니다.

    @media (min-width: 768px) and (max-width: 1024px) { ... }
        : and는 연결된 모든 표현식이 참이면 적용됩니다.(and 키워드는 연결된 부분이 모두 참이어야 적용이 됩니다.)

    @media (color-index)
        : 미디어 장치가 color-index를 지원하면 적용됩니다.

    @media screen and (min-width: 768px), screen and (orientation: portrait), ...
        : 쉼표로 연결된 미디어 쿼리 중 하나라도 참이면 적용됩니다.( and 키워드와 반대라고 생각하면 됩니다.)

    @media not screen and (min-width: 768px)
        : not 키워드는 하나의 media_query 전체를 부정합니다.
        : (not screen) and (min-width: 768px) 잘못된 해석!
        : not (screen and (min-width: 768px)) 올바른 해석!
        : @media not screen and (min-width: 768px), print
           첫 번째 미디어 쿼리에만 not 키워드가 적용되며, 두 번째 미디어 쿼리(print)에는 영향이 없습니다.-->

미디어 쿼리 선언 방법

<!--미디어 쿼리를 선언하는 3가지 방법에 대해 알아보겠습니다.
    참고로 @media를 이용한 방법을 가장 많이 사용하며 나머지 2가지 방법은 거의 쓰이지 않습니다.

    @media screen and (color)
    : CSS 파일 내부에 또는 <style> 태그 내부에 사용가능 합니다. 대부분의 경우 이렇게 사용합니다.

    <link rel="stylesheet" media="screen and (color)" href="example.css">
    : <link> 태그의 media 속성에 미디어 쿼리를 선언합니다. 미디어 쿼리가 참이면 뒤에 css 파일 규칙이 적용됩니다.

    @import url(example.css) screen and (color);
    : CSS 파일 내부에 또는 <style> 태그 내부에 사용가능 합니다. @import문 뒤에 미디어 쿼리를 선언하면 됩니다. -->


viewport의 이해
<!--스마트폰 이전 시대에는 대부분의 웹 페이지가 데스크탑 모니터 사이즈를 고려해서 제작되었기 때문에
    모바일 기기처럼 작은 화면에서는 모두 보이지 않아 좌우로 스크롤을 해야만 내용을 볼 수가 있었습니다.
    그래서 모바일 브라우저들은 뷰포트(viewport)라는 가상의 화면을 만들고 그 화면에 페이지를 나타내기 시작했습니다.
    (기기마다 다르지만 대부분 일반적인 데스크탑 모니터 사이즈와 비슷하게 대부분 980px 입니다.)
    여기에서 실제 우리가 보는 스마트폰의 스크린 사이즈(device-width/height)와
    브라우저가 화면을 나타내는 가상의 화면 사이즈(viewport)의 차이가 생기게 됩니다.
    기본 뷰포트의 크기가 980px이기 때문에 width가 980px 정도인 웹 페이지를 모바일 브라우저로 보게 되면
    가로 스크롤 없이 딱 화면에 맞춰 나옵니다. 그렇게 되면  스크롤 하지 않아도 내용이 다 보여지는 장점이 있지만
    글자나 그림들이 그 폭에 맞춰서 작아지기 때문에 가독성이 매우 떨어집니다.
    그래서 모바일 safari에서 뷰포트를 설정할 수 있는 태그를 도입해서
    뷰포트의 크기와 스케일을 조정할 수 있게 했습니다. -->

뷰포트 설정
<!--뷰포트를 설정하는 태그는 <meta> 태그로 <head> 태그에 위치해야 합니다.
    name 속성에 "viewport"라고 선언하며 content 속성에 뷰포트를 설정하는 내용이 들어갑니다.  -->
<meta name="viewport" content=" 뷰포트의 설정 값">
<!--content에는 몇 가지 설정을 할 수 있습니다.

    width(height) : 뷰포트의 가로(세로) 크기를 지정합니다. px단위의 수치가 들어갈 수 있지만,
    대부분 특수 키워드인 "device-width(height)"를 사용합니다.
    (뷰포트의 크기를 기기의 스크린 width(height) 크기로 설정한다는 의미입니다.)
    initial-scale : 페이지가 처음 나타날 때 초기 줌 레벨 값을 설정합니다.(소수값)
    user-scalable : 사용자의 확대/축소 기능을 설정할 수 있습니다. 기본값 yes-->

대부분의 모바일 웹 사이트의 뷰포트 설정은 아래와 같습니다. 기타 다른 설정은 필요에 따라 하시면 됩니다.
<meta name="viewport" content="width=device-width, initial-scale=1.0">


transform
<!--어떤 요소를 변형 할 때 사용하는 속성이다
    해당 요소에 속성을 주면 자기 본래 위치를 기억해 다른 요소가 그 위치다음에 위치한다.
    -속성값-
    rotate(45deg):원하는 각도로 돌릴 수 있는 속성 단위는 degdaq
    scale():확대 축소 기능 괄호안에 숫자는 배로 읽는다.(소수점가능)
    translate(X,Y):위치를 이동시키는 속성값이다.-->


transition
<!--해당 요소에 애니메이션으로 줘서 자연스럽게 해당속성에서 다른 속성으로 바뀌게 해주는 속성

   <필수 속성값>
   []은 생략가능
    property: 해당 요소에 변화를 주고 싶은  속성(font-size, backgroun.. 등등)
              모두 주고 싶을때 all, 각각 다르게 주고 싶을 때 ","
    duration: 지속시간 단위는 ms, s 1,000ms=1s
    [timing-function]: 속도를 지정해주는 값이다.여러값이 있다(ease-in,ease-out, ease-in-out cubic-bezier())
                      ease-in: 천천히 바뀌다가 나중에 확바뀌는 속성값이다
                      ease-out: 위에 반대이다
                      ease-in-out: in out 짬뽕이다.
                      cubic-bezier(): 바뀌는 속도을 지정(cubic-bezier.com 들어가서 커스텀해서 코드를 복사해서 사용)
    [delay]: 몇초 후에 바뀌 값을 지정하는 속성값이다.
    []은 생략가능-->


animation
<!--그냥 애니메이션 주고 싶을 때 사용 좀더 자유도가 높다
    animation은 속성값이 많고 순서도 있어서 헷갈리 요소가 있다
    그래서 animation-property처럼 선언해서 사용하는 것이 낫다.
  <속성값>
    name: @keyframes name(아무이름){
      from{
     property
   }

   to{
   property
 }
  }
OR
        @keyframes name{
          0%{
            property
          }

          50%{
            propery
          }

          100%{
           propery
        }
        }
  주고 싶은 요소의 class 속성에 animation-name : name 주면 끝

  duration(지속시간): 지속시간 단위는 ms, s 1,000ms=1s

  timing-function: 몇초 후에 바뀌는지를 지정하는 속성값이다.

  delay: 몇초 후에 바뀌 값을 지정하는 속성값이다.

  iteration(반복)-count: 반복횟수를 지정 무한으로 하고싶으면 infinite값을 지정

  direction(위치 이동의 방향): alternate(번갈아 생기는) 값을 주면 form에서 to 다시 to에서 form으로 서로 번갈아가면서 동작하라는 속성값이다-->


box shadow
<!--요소한테 그림자를 줄 때 사용하는 속성
    요즘트렌드는 neomorphism이다
    x,y 흐린 정도 그림자 사이즈 색상 지정
    <속성값>=순서 중요
    h-offset: x축 위치지정
    v-offset:  y축 위치지정
    blur: 흐린 정도 숫자가 0= 흐리지 않음
    spread: 그림자 사이즈
    color: 색상
  위 순서대로 다음과 같이 작성하면 된다.
box shadow: 1px(x) 2px(y) blur spread color
-->


bootstrap
<!-- 그리드 시스템을 쉽게 css로 구현해주는 프레임 워크 반응형도 대응됨
사용법 구글에 bootstrap 검색, 홈페이지 접속후 link 태그 복사 head태그에 붙이기
bodyd에 div태그에 container클래스 달아주고 그다음 자식요소로 div에 row클래스 달아준다
마지막으로 또 자식요소에 col-12(칸수최대가 12개이다) 클래스를 달아준다

!!!단 주의사항 위 선언 순서는 반드시 지켜야할 것
    row안에 col클래스 없이 다른 클래스 선언하지 말고
    꼭 col클래스 선언후 그 안에 다른 클래스를 선언할 것.
    and width height padding-left padding-rigth margin-left margin-right
    절대 건들지 말것 단 col 요소간에 간격은 상관없음.!!!

    row 같은경우 bootstrap에서 제공하는 속성이 있는데
    row은 flex를 사용하고 있어 row에도 가운데 정렬 하고 싶으면 justify-contents-center OR 
    align-items-center를 주면 한줄에 가운데 정렬를 할 수 있다.

또한, bootstrap은 반응형도 대응되도록 설계됐다
페이지 크기에 마다 container width의 크기가 그에 맞게
조절 되고 그에 따른 값에는 다음과 같다.
1400px이상=1320px
1200px이상=1140px
992px이상=960px
768px이상=720px
576px이상=540px
576px이하=width:100%(페이지 전체)-->


Reset CSS
<!--기본적으로 브라우저에서 적용된 스타일들을 초기화 시키는 작업-->
a {
    color: inherit;
    text-decoration:none;
} 

button,
input,
textarea {
    font-family: "DM Sans", snas-serif;
    font-size: 16px;
}
<!--박스안에 글자들은 폰트체가 먹지 않아 따로 선언해줘야 한다.-->

button:focus,
button:active
input:focus,
input:active
textarea:focus,
textarea:active {
    outline: none;
    box-shadow: none;
}
<!--위 요소들을 포커스 나 클릭 했을 시 적용된 스타일을 없애는 작업-->

ul,
ol,
li {
    list-style-type: none;
    padding-left: 0;
    margin-left: 0;
}

